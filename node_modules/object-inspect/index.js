var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match = String.prototype.match;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) ***REMOVED***
            return O.__proto__; // eslint-disable-line no-proto
        ***REMOVED***
        : null
);

var inspectCustom = require('./util.inspect').custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) ***REMOVED***
    var opts = options || ***REMOVED******REMOVED***;

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) ***REMOVED***
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    ***REMOVED***
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) ***REMOVED***
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    ***REMOVED***
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') ***REMOVED***
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    ***REMOVED***

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) ***REMOVED***
        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
    ***REMOVED***

    if (typeof obj === 'undefined') ***REMOVED***
        return 'undefined';
    ***REMOVED***
    if (obj === null) ***REMOVED***
        return 'null';
    ***REMOVED***
    if (typeof obj === 'boolean') ***REMOVED***
        return obj ? 'true' : 'false';
    ***REMOVED***

    if (typeof obj === 'string') ***REMOVED***
        return inspectString(obj, opts);
    ***REMOVED***
    if (typeof obj === 'number') ***REMOVED***
        if (obj === 0) ***REMOVED***
            return Infinity / obj > 0 ? '0' : '-0';
        ***REMOVED***
        return String(obj);
    ***REMOVED***
    if (typeof obj === 'bigint') ***REMOVED***
        return String(obj) + 'n';
    ***REMOVED***

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') ***REMOVED*** depth = 0; ***REMOVED***
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') ***REMOVED***
        return isArray(obj) ? '[Array]' : '[Object]';
    ***REMOVED***

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') ***REMOVED***
        seen = [];
    ***REMOVED*** else if (indexOf(seen, obj) >= 0) ***REMOVED***
        return '[Circular]';
    ***REMOVED***

    function inspect(value, from, noIndent) ***REMOVED***
        if (from) ***REMOVED***
            seen = seen.slice();
            seen.push(from);
        ***REMOVED***
        if (noIndent) ***REMOVED***
            var newOpts = ***REMOVED***
                depth: opts.depth
            ***REMOVED***;
            if (has(opts, 'quoteStyle')) ***REMOVED***
                newOpts.quoteStyle = opts.quoteStyle;
            ***REMOVED***
            return inspect_(value, newOpts, depth + 1, seen);
        ***REMOVED***
        return inspect_(value, opts, depth + 1, seen);
    ***REMOVED***

    if (typeof obj === 'function') ***REMOVED***
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' ***REMOVED*** ' + keys.join(', ') + ' ***REMOVED***' : '');
    ***REMOVED***
    if (isSymbol(obj)) ***REMOVED***
        var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    ***REMOVED***
    if (isElement(obj)) ***REMOVED***
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) ***REMOVED***
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        ***REMOVED***
        s += '>';
        if (obj.childNodes && obj.childNodes.length) ***REMOVED*** s += '...'; ***REMOVED***
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    ***REMOVED***
    if (isArray(obj)) ***REMOVED***
        if (obj.length === 0) ***REMOVED*** return '[]'; ***REMOVED***
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) ***REMOVED***
            return '[' + indentedJoin(xs, indent) + ']';
        ***REMOVED***
        return '[ ' + xs.join(', ') + ' ]';
    ***REMOVED***
    if (isError(obj)) ***REMOVED***
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) ***REMOVED*** return '[' + String(obj) + ']'; ***REMOVED***
        return '***REMOVED*** [' + String(obj) + '] ' + parts.join(', ') + ' ***REMOVED***';
    ***REMOVED***
    if (typeof obj === 'object' && customInspect) ***REMOVED***
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') ***REMOVED***
            return obj[inspectSymbol]();
        ***REMOVED*** else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') ***REMOVED***
            return obj.inspect();
        ***REMOVED***
    ***REMOVED***
    if (isMap(obj)) ***REMOVED***
        var mapParts = [];
        mapForEach.call(obj, function (value, key) ***REMOVED***
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        ***REMOVED***);
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    ***REMOVED***
    if (isSet(obj)) ***REMOVED***
        var setParts = [];
        setForEach.call(obj, function (value) ***REMOVED***
            setParts.push(inspect(value, obj));
        ***REMOVED***);
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    ***REMOVED***
    if (isWeakMap(obj)) ***REMOVED***
        return weakCollectionOf('WeakMap');
    ***REMOVED***
    if (isWeakSet(obj)) ***REMOVED***
        return weakCollectionOf('WeakSet');
    ***REMOVED***
    if (isWeakRef(obj)) ***REMOVED***
        return weakCollectionOf('WeakRef');
    ***REMOVED***
    if (isNumber(obj)) ***REMOVED***
        return markBoxed(inspect(Number(obj)));
    ***REMOVED***
    if (isBigInt(obj)) ***REMOVED***
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    ***REMOVED***
    if (isBoolean(obj)) ***REMOVED***
        return markBoxed(booleanValueOf.call(obj));
    ***REMOVED***
    if (isString(obj)) ***REMOVED***
        return markBoxed(inspect(String(obj)));
    ***REMOVED***
    if (!isDate(obj) && !isRegExp(obj)) ***REMOVED***
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr(obj).slice(8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + [].concat(stringTag || [], protoTag || []).join(': ') + '] ' : '');
        if (ys.length === 0) ***REMOVED*** return tag + '***REMOVED******REMOVED***'; ***REMOVED***
        if (indent) ***REMOVED***
            return tag + '***REMOVED***' + indentedJoin(ys, indent) + '***REMOVED***';
        ***REMOVED***
        return tag + '***REMOVED*** ' + ys.join(', ') + ' ***REMOVED***';
    ***REMOVED***
    return String(obj);
***REMOVED***;

function wrapQuotes(s, defaultStyle, opts) ***REMOVED***
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
***REMOVED***

function quote(s) ***REMOVED***
    return String(s).replace(/"/g, '&quot;');
***REMOVED***

function isArray(obj) ***REMOVED*** return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); ***REMOVED***
function isDate(obj) ***REMOVED*** return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); ***REMOVED***
function isRegExp(obj) ***REMOVED*** return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); ***REMOVED***
function isError(obj) ***REMOVED*** return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); ***REMOVED***
function isString(obj) ***REMOVED*** return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); ***REMOVED***
function isNumber(obj) ***REMOVED*** return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); ***REMOVED***
function isBoolean(obj) ***REMOVED*** return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); ***REMOVED***

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) ***REMOVED***
    if (hasShammedSymbols) ***REMOVED***
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    ***REMOVED***
    if (typeof obj === 'symbol') ***REMOVED***
        return true;
    ***REMOVED***
    if (!obj || typeof obj !== 'object' || !symToString) ***REMOVED***
        return false;
    ***REMOVED***
    try ***REMOVED***
        symToString.call(obj);
        return true;
    ***REMOVED*** catch (e) ***REMOVED******REMOVED***
    return false;
***REMOVED***

function isBigInt(obj) ***REMOVED***
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) ***REMOVED***
        return false;
    ***REMOVED***
    try ***REMOVED***
        bigIntValueOf.call(obj);
        return true;
    ***REMOVED*** catch (e) ***REMOVED******REMOVED***
    return false;
***REMOVED***

var hasOwn = Object.prototype.hasOwnProperty || function (key) ***REMOVED*** return key in this; ***REMOVED***;
function has(obj, key) ***REMOVED***
    return hasOwn.call(obj, key);
***REMOVED***

function toStr(obj) ***REMOVED***
    return objectToString.call(obj);
***REMOVED***

function nameOf(f) ***REMOVED***
    if (f.name) ***REMOVED*** return f.name; ***REMOVED***
    var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) ***REMOVED*** return m[1]; ***REMOVED***
    return null;
***REMOVED***

function indexOf(xs, x) ***REMOVED***
    if (xs.indexOf) ***REMOVED*** return xs.indexOf(x); ***REMOVED***
    for (var i = 0, l = xs.length; i < l; i++) ***REMOVED***
        if (xs[i] === x) ***REMOVED*** return i; ***REMOVED***
    ***REMOVED***
    return -1;
***REMOVED***

function isMap(x) ***REMOVED***
    if (!mapSize || !x || typeof x !== 'object') ***REMOVED***
        return false;
    ***REMOVED***
    try ***REMOVED***
        mapSize.call(x);
        try ***REMOVED***
            setSize.call(x);
        ***REMOVED*** catch (s) ***REMOVED***
            return true;
        ***REMOVED***
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    ***REMOVED*** catch (e) ***REMOVED******REMOVED***
    return false;
***REMOVED***

function isWeakMap(x) ***REMOVED***
    if (!weakMapHas || !x || typeof x !== 'object') ***REMOVED***
        return false;
    ***REMOVED***
    try ***REMOVED***
        weakMapHas.call(x, weakMapHas);
        try ***REMOVED***
            weakSetHas.call(x, weakSetHas);
        ***REMOVED*** catch (s) ***REMOVED***
            return true;
        ***REMOVED***
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    ***REMOVED*** catch (e) ***REMOVED******REMOVED***
    return false;
***REMOVED***

function isWeakRef(x) ***REMOVED***
    if (!weakRefDeref || !x || typeof x !== 'object') ***REMOVED***
        return false;
    ***REMOVED***
    try ***REMOVED***
        weakRefDeref.call(x);
        return true;
    ***REMOVED*** catch (e) ***REMOVED******REMOVED***
    return false;
***REMOVED***

function isSet(x) ***REMOVED***
    if (!setSize || !x || typeof x !== 'object') ***REMOVED***
        return false;
    ***REMOVED***
    try ***REMOVED***
        setSize.call(x);
        try ***REMOVED***
            mapSize.call(x);
        ***REMOVED*** catch (m) ***REMOVED***
            return true;
        ***REMOVED***
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    ***REMOVED*** catch (e) ***REMOVED******REMOVED***
    return false;
***REMOVED***

function isWeakSet(x) ***REMOVED***
    if (!weakSetHas || !x || typeof x !== 'object') ***REMOVED***
        return false;
    ***REMOVED***
    try ***REMOVED***
        weakSetHas.call(x, weakSetHas);
        try ***REMOVED***
            weakMapHas.call(x, weakMapHas);
        ***REMOVED*** catch (s) ***REMOVED***
            return true;
        ***REMOVED***
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    ***REMOVED*** catch (e) ***REMOVED******REMOVED***
    return false;
***REMOVED***

function isElement(x) ***REMOVED***
    if (!x || typeof x !== 'object') ***REMOVED*** return false; ***REMOVED***
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) ***REMOVED***
        return true;
    ***REMOVED***
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
***REMOVED***

function inspectString(str, opts) ***REMOVED***
    if (str.length > opts.maxStringLength) ***REMOVED***
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
    ***REMOVED***
    // eslint-disable-next-line no-control-regex
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
***REMOVED***

function lowbyte(c) ***REMOVED***
    var n = c.charCodeAt(0);
    var x = ***REMOVED***
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    ***REMOVED***[n];
    if (x) ***REMOVED*** return '\\' + x; ***REMOVED***
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16).toUpperCase();
***REMOVED***

function markBoxed(str) ***REMOVED***
    return 'Object(' + str + ')';
***REMOVED***

function weakCollectionOf(type) ***REMOVED***
    return type + ' ***REMOVED*** ? ***REMOVED***';
***REMOVED***

function collectionOf(type, size, entries, indent) ***REMOVED***
    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');
    return type + ' (' + size + ') ***REMOVED***' + joinedEntries + '***REMOVED***';
***REMOVED***

function singleLineValues(xs) ***REMOVED***
    for (var i = 0; i < xs.length; i++) ***REMOVED***
        if (indexOf(xs[i], '\n') >= 0) ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***
    return true;
***REMOVED***

function getIndent(opts, depth) ***REMOVED***
    var baseIndent;
    if (opts.indent === '\t') ***REMOVED***
        baseIndent = '\t';
    ***REMOVED*** else if (typeof opts.indent === 'number' && opts.indent > 0) ***REMOVED***
        baseIndent = Array(opts.indent + 1).join(' ');
    ***REMOVED*** else ***REMOVED***
        return null;
    ***REMOVED***
    return ***REMOVED***
        base: baseIndent,
        prev: Array(depth + 1).join(baseIndent)
    ***REMOVED***;
***REMOVED***

function indentedJoin(xs, indent) ***REMOVED***
    if (xs.length === 0) ***REMOVED*** return ''; ***REMOVED***
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + xs.join(',' + lineJoiner) + '\n' + indent.prev;
***REMOVED***

function arrObjKeys(obj, inspect) ***REMOVED***
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) ***REMOVED***
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) ***REMOVED***
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        ***REMOVED***
    ***REMOVED***
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) ***REMOVED***
        symMap = ***REMOVED******REMOVED***;
        for (var k = 0; k < syms.length; k++) ***REMOVED***
            symMap['$' + syms[k]] = syms[k];
        ***REMOVED***
    ***REMOVED***

    for (var key in obj) ***REMOVED*** // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) ***REMOVED*** continue; ***REMOVED*** // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) ***REMOVED*** continue; ***REMOVED*** // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) ***REMOVED***
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        ***REMOVED*** else if ((/[^\w$]/).test(key)) ***REMOVED***
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        ***REMOVED*** else ***REMOVED***
            xs.push(key + ': ' + inspect(obj[key], obj));
        ***REMOVED***
    ***REMOVED***
    if (typeof gOPS === 'function') ***REMOVED***
        for (var j = 0; j < syms.length; j++) ***REMOVED***
            if (isEnumerable.call(obj, syms[j])) ***REMOVED***
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    return xs;
***REMOVED***
