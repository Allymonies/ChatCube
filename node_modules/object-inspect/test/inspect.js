var test = require('tape');
var hasSymbols = require('has-symbols/shams')();
var utilInspect = require('../util.inspect');
var repeat = require('string.prototype.repeat');

var inspect = require('..');

test('inspect', function (t) ***REMOVED***
    t.plan(5);

    var obj = [***REMOVED*** inspect: function xyzInspect() ***REMOVED*** return '!XYZ¡'; ***REMOVED*** ***REMOVED***, []];
    var stringResult = '[ !XYZ¡, [] ]';
    var falseResult = '[ ***REMOVED*** inspect: [Function: xyzInspect] ***REMOVED***, [] ]';

    t.equal(inspect(obj), stringResult);
    t.equal(inspect(obj, ***REMOVED*** customInspect: true ***REMOVED***), stringResult);
    t.equal(inspect(obj, ***REMOVED*** customInspect: 'symbol' ***REMOVED***), falseResult);
    t.equal(inspect(obj, ***REMOVED*** customInspect: false ***REMOVED***), falseResult);
    t['throws'](
        function () ***REMOVED*** inspect(obj, ***REMOVED*** customInspect: 'not a boolean or "symbol"' ***REMOVED***); ***REMOVED***,
        TypeError,
        '`customInspect` must be a boolean or the string "symbol"'
    );
***REMOVED***);

test('inspect custom symbol', ***REMOVED*** skip: !hasSymbols || !utilInspect || !utilInspect.custom ***REMOVED***, function (t) ***REMOVED***
    t.plan(4);

    var obj = ***REMOVED*** inspect: function stringInspect() ***REMOVED*** return 'string'; ***REMOVED*** ***REMOVED***;
    obj[utilInspect.custom] = function custom() ***REMOVED*** return 'symbol'; ***REMOVED***;

    var symbolResult = '[ symbol, [] ]';
    var stringResult = '[ string, [] ]';
    var falseResult = '[ ***REMOVED*** inspect: [Function: stringInspect]' + (utilInspect.custom ? ', [' + inspect(utilInspect.custom) + ']: [Function: custom]' : '') + ' ***REMOVED***, [] ]';

    var symbolStringFallback = utilInspect.custom ? symbolResult : stringResult;
    var symbolFalseFallback = utilInspect.custom ? symbolResult : falseResult;

    t.equal(inspect([obj, []]), symbolStringFallback);
    t.equal(inspect([obj, []], ***REMOVED*** customInspect: true ***REMOVED***), symbolStringFallback);
    t.equal(inspect([obj, []], ***REMOVED*** customInspect: 'symbol' ***REMOVED***), symbolFalseFallback);
    t.equal(inspect([obj, []], ***REMOVED*** customInspect: false ***REMOVED***), falseResult);
***REMOVED***);

test('symbols', ***REMOVED*** skip: !hasSymbols ***REMOVED***, function (t) ***REMOVED***
    t.plan(2);

    var obj = ***REMOVED*** a: 1 ***REMOVED***;
    obj[Symbol('test')] = 2;
    obj[Symbol.iterator] = 3;
    Object.defineProperty(obj, Symbol('non-enum'), ***REMOVED***
        enumerable: false,
        value: 4
    ***REMOVED***);

    if (typeof Symbol.iterator === 'symbol') ***REMOVED***
        t.equal(inspect(obj), '***REMOVED*** a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 ***REMOVED***', 'object with symbols');
        t.equal(inspect([obj, []]), '[ ***REMOVED*** a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 ***REMOVED***, [] ]', 'object with symbols in array');
    ***REMOVED*** else ***REMOVED***
        // symbol sham key ordering is unreliable
        t.match(
            inspect(obj),
            /^(?:***REMOVED*** a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 ***REMOVED***|***REMOVED*** a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 ***REMOVED***)$/,
            'object with symbols (nondeterministic symbol sham key ordering)'
        );
        t.match(
            inspect([obj, []]),
            /^\[ (?:***REMOVED*** a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 ***REMOVED***|***REMOVED*** a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 ***REMOVED***), \[\] \]$/,
            'object with symbols in array (nondeterministic symbol sham key ordering)'
        );
    ***REMOVED***
***REMOVED***);

test('maxStringLength', function (t) ***REMOVED***
    t['throws'](
        function () ***REMOVED*** inspect('', ***REMOVED*** maxStringLength: -1 ***REMOVED***); ***REMOVED***,
        TypeError,
        'maxStringLength must be >= 0, or Infinity, not negative'
    );

    var str = repeat('a', 1e8);

    t.equal(
        inspect([str], ***REMOVED*** maxStringLength: 10 ***REMOVED***),
        '[ \'aaaaaaaaaa\'... 99999990 more characters ]',
        'maxStringLength option limits output'
    );

    t.equal(
        inspect(['f'], ***REMOVED*** maxStringLength: null ***REMOVED***),
        '[ \'\'... 1 more character ]',
        'maxStringLength option accepts `null`'
    );

    t.equal(
        inspect([str], ***REMOVED*** maxStringLength: Infinity ***REMOVED***),
        '[ \'' + str + '\' ]',
        'maxStringLength option accepts ∞'
    );

    t.end();
***REMOVED***);
