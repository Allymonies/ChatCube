'use strict';

var inspect = require('../');
var test = require('tape');
var hasSymbols = require('has-symbols/shams')();
var hasToStringTag = require('has-tostringtag/shams')();

test('values', function (t) ***REMOVED***
    t.plan(1);
    var obj = [***REMOVED******REMOVED***, [], ***REMOVED*** 'a-b': 5 ***REMOVED***];
    t.equal(inspect(obj), '[ ***REMOVED******REMOVED***, [], ***REMOVED*** \'a-b\': 5 ***REMOVED*** ]');
***REMOVED***);

test('arrays with properties', function (t) ***REMOVED***
    t.plan(1);
    var arr = [3];
    arr.foo = 'bar';
    var obj = [1, 2, arr];
    obj.baz = 'quux';
    obj.index = -1;
    t.equal(inspect(obj), '[ 1, 2, [ 3, foo: \'bar\' ], baz: \'quux\', index: -1 ]');
***REMOVED***);

test('has', function (t) ***REMOVED***
    t.plan(1);
    var has = Object.prototype.hasOwnProperty;
    delete Object.prototype.hasOwnProperty;
    t.equal(inspect(***REMOVED*** a: 1, b: 2 ***REMOVED***), '***REMOVED*** a: 1, b: 2 ***REMOVED***');
    Object.prototype.hasOwnProperty = has; // eslint-disable-line no-extend-native
***REMOVED***);

test('indexOf seen', function (t) ***REMOVED***
    t.plan(1);
    var xs = [1, 2, 3, ***REMOVED******REMOVED***];
    xs.push(xs);

    var seen = [];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, ***REMOVED******REMOVED***, 0, seen),
        '[ 1, 2, 3, ***REMOVED******REMOVED***, [Circular] ]'
    );
***REMOVED***);

test('seen seen', function (t) ***REMOVED***
    t.plan(1);
    var xs = [1, 2, 3];

    var seen = [xs];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, ***REMOVED******REMOVED***, 0, seen),
        '[Circular]'
    );
***REMOVED***);

test('seen seen seen', function (t) ***REMOVED***
    t.plan(1);
    var xs = [1, 2, 3];

    var seen = [5, xs];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, ***REMOVED******REMOVED***, 0, seen),
        '[Circular]'
    );
***REMOVED***);

test('symbols', ***REMOVED*** skip: !hasSymbols ***REMOVED***, function (t) ***REMOVED***
    var sym = Symbol('foo');
    t.equal(inspect(sym), 'Symbol(foo)', 'Symbol("foo") should be "Symbol(foo)"');
    if (typeof sym === 'symbol') ***REMOVED***
        // Symbol shams are incapable of differentiating boxed from unboxed symbols
        t.equal(inspect(Object(sym)), 'Object(Symbol(foo))', 'Object(Symbol("foo")) should be "Object(Symbol(foo))"');
    ***REMOVED***

    t.test('toStringTag', ***REMOVED*** skip: !hasToStringTag ***REMOVED***, function (st) ***REMOVED***
        st.plan(1);

        var faker = ***REMOVED******REMOVED***;
        faker[Symbol.toStringTag] = 'Symbol';
        st.equal(
            inspect(faker),
            '***REMOVED*** [Symbol(Symbol.toStringTag)]: \'Symbol\' ***REMOVED***',
            'object lying about being a Symbol inspects as an object'
        );
    ***REMOVED***);

    t.end();
***REMOVED***);

test('Map', ***REMOVED*** skip: typeof Map !== 'function' ***REMOVED***, function (t) ***REMOVED***
    var map = new Map();
    map.set(***REMOVED*** a: 1 ***REMOVED***, ['b']);
    map.set(3, NaN);
    var expectedString = 'Map (2) ***REMOVED***' + inspect(***REMOVED*** a: 1 ***REMOVED***) + ' => ' + inspect(['b']) + ', 3 => NaN***REMOVED***';
    t.equal(inspect(map), expectedString, 'new Map([[***REMOVED*** a: 1 ***REMOVED***, ["b"]], [3, NaN]]) should show size and contents');
    t.equal(inspect(new Map()), 'Map (0) ***REMOVED******REMOVED***', 'empty Map should show as empty');

    var nestedMap = new Map();
    nestedMap.set(nestedMap, map);
    t.equal(inspect(nestedMap), 'Map (1) ***REMOVED***[Circular] => ' + expectedString + '***REMOVED***', 'Map containing a Map should work');

    t.end();
***REMOVED***);

test('WeakMap', ***REMOVED*** skip: typeof WeakMap !== 'function' ***REMOVED***, function (t) ***REMOVED***
    var map = new WeakMap();
    map.set(***REMOVED*** a: 1 ***REMOVED***, ['b']);
    var expectedString = 'WeakMap ***REMOVED*** ? ***REMOVED***';
    t.equal(inspect(map), expectedString, 'new WeakMap([[***REMOVED*** a: 1 ***REMOVED***, ["b"]]]) should not show size or contents');
    t.equal(inspect(new WeakMap()), 'WeakMap ***REMOVED*** ? ***REMOVED***', 'empty WeakMap should not show as empty');

    t.end();
***REMOVED***);

test('Set', ***REMOVED*** skip: typeof Set !== 'function' ***REMOVED***, function (t) ***REMOVED***
    var set = new Set();
    set.add(***REMOVED*** a: 1 ***REMOVED***);
    set.add(['b']);
    var expectedString = 'Set (2) ***REMOVED***' + inspect(***REMOVED*** a: 1 ***REMOVED***) + ', ' + inspect(['b']) + '***REMOVED***';
    t.equal(inspect(set), expectedString, 'new Set([***REMOVED*** a: 1 ***REMOVED***, ["b"]]) should show size and contents');
    t.equal(inspect(new Set()), 'Set (0) ***REMOVED******REMOVED***', 'empty Set should show as empty');

    var nestedSet = new Set();
    nestedSet.add(set);
    nestedSet.add(nestedSet);
    t.equal(inspect(nestedSet), 'Set (2) ***REMOVED***' + expectedString + ', [Circular]***REMOVED***', 'Set containing a Set should work');

    t.end();
***REMOVED***);

test('WeakSet', ***REMOVED*** skip: typeof WeakSet !== 'function' ***REMOVED***, function (t) ***REMOVED***
    var map = new WeakSet();
    map.add(***REMOVED*** a: 1 ***REMOVED***);
    var expectedString = 'WeakSet ***REMOVED*** ? ***REMOVED***';
    t.equal(inspect(map), expectedString, 'new WeakSet([***REMOVED*** a: 1 ***REMOVED***]) should not show size or contents');
    t.equal(inspect(new WeakSet()), 'WeakSet ***REMOVED*** ? ***REMOVED***', 'empty WeakSet should not show as empty');

    t.end();
***REMOVED***);

test('WeakRef', ***REMOVED*** skip: typeof WeakRef !== 'function' ***REMOVED***, function (t) ***REMOVED***
    var ref = new WeakRef(***REMOVED*** a: 1 ***REMOVED***);
    var expectedString = 'WeakRef ***REMOVED*** ? ***REMOVED***';
    t.equal(inspect(ref), expectedString, 'new WeakRef(***REMOVED*** a: 1 ***REMOVED***) should not show contents');

    t.end();
***REMOVED***);

test('FinalizationRegistry', ***REMOVED*** skip: typeof FinalizationRegistry !== 'function' ***REMOVED***, function (t) ***REMOVED***
    var registry = new FinalizationRegistry(function () ***REMOVED******REMOVED***);
    var expectedString = 'FinalizationRegistry [FinalizationRegistry] ***REMOVED******REMOVED***';
    t.equal(inspect(registry), expectedString, 'new FinalizationRegistry(function () ***REMOVED******REMOVED***) should work normallys');

    t.end();
***REMOVED***);

test('Strings', function (t) ***REMOVED***
    var str = 'abc';

    t.equal(inspect(str), "'" + str + "'", 'primitive string shows as such');
    t.equal(inspect(str, ***REMOVED*** quoteStyle: 'single' ***REMOVED***), "'" + str + "'", 'primitive string shows as such, single quoted');
    t.equal(inspect(str, ***REMOVED*** quoteStyle: 'double' ***REMOVED***), '"' + str + '"', 'primitive string shows as such, double quoted');
    t.equal(inspect(Object(str)), 'Object(' + inspect(str) + ')', 'String object shows as such');
    t.equal(inspect(Object(str), ***REMOVED*** quoteStyle: 'single' ***REMOVED***), 'Object(' + inspect(str, ***REMOVED*** quoteStyle: 'single' ***REMOVED***) + ')', 'String object shows as such, single quoted');
    t.equal(inspect(Object(str), ***REMOVED*** quoteStyle: 'double' ***REMOVED***), 'Object(' + inspect(str, ***REMOVED*** quoteStyle: 'double' ***REMOVED***) + ')', 'String object shows as such, double quoted');

    t.end();
***REMOVED***);

test('Numbers', function (t) ***REMOVED***
    var num = 42;

    t.equal(inspect(num), String(num), 'primitive number shows as such');
    t.equal(inspect(Object(num)), 'Object(' + inspect(num) + ')', 'Number object shows as such');

    t.end();
***REMOVED***);

test('Booleans', function (t) ***REMOVED***
    t.equal(inspect(true), String(true), 'primitive true shows as such');
    t.equal(inspect(Object(true)), 'Object(' + inspect(true) + ')', 'Boolean object true shows as such');

    t.equal(inspect(false), String(false), 'primitive false shows as such');
    t.equal(inspect(Object(false)), 'Object(' + inspect(false) + ')', 'Boolean false object shows as such');

    t.end();
***REMOVED***);

test('Date', function (t) ***REMOVED***
    var now = new Date();
    t.equal(inspect(now), String(now), 'Date shows properly');
    t.equal(inspect(new Date(NaN)), 'Invalid Date', 'Invalid Date shows properly');

    t.end();
***REMOVED***);

test('RegExps', function (t) ***REMOVED***
    t.equal(inspect(/a/g), '/a/g', 'regex shows properly');
    t.equal(inspect(new RegExp('abc', 'i')), '/abc/i', 'new RegExp shows properly');

    var match = 'abc abc'.match(/[ab]+/);
    delete match.groups; // for node < 10
    t.equal(inspect(match), '[ \'ab\', index: 0, input: \'abc abc\' ]', 'RegExp match object shows properly');

    t.end();
***REMOVED***);
