import ***REMOVED*** __read, __values ***REMOVED*** from "tslib";
import ***REMOVED*** splitWithLimit ***REMOVED*** from '@d-fischer/shared-utils';
import ***REMOVED*** defaultServerProperties ***REMOVED*** from "../ServerProperties.mjs";
import ***REMOVED*** Message ***REMOVED*** from "./Message.mjs";
import ***REMOVED*** all as coreMessageTypes ***REMOVED*** from "./MessageTypes/index.mjs";
export function parsePrefix(raw) ***REMOVED***
    var _a = __read(splitWithLimit(raw, '!', 2), 2), nick = _a[0], hostName = _a[1];
    if (hostName) ***REMOVED***
        var _b = __read(splitWithLimit(hostName, '@', 2), 2), user = _b[0], host = _b[1];
        if (host) ***REMOVED***
            return ***REMOVED*** nick: nick, user: user, host: host ***REMOVED***;
        ***REMOVED***
        else ***REMOVED***
            return ***REMOVED*** nick: nick, host: user ***REMOVED***;
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
        return ***REMOVED*** nick: nick ***REMOVED***;
    ***REMOVED***
***REMOVED***
var tagUnescapeMap = ***REMOVED***
    ':': ';',
    n: '\n',
    r: '\r',
    s: ' '
***REMOVED***;
export function parseTags(raw) ***REMOVED***
    var e_1, _a;
    var tags = new Map();
    var tagStrings = raw.split(';');
    try ***REMOVED***
        for (var tagStrings_1 = __values(tagStrings), tagStrings_1_1 = tagStrings_1.next(); !tagStrings_1_1.done; tagStrings_1_1 = tagStrings_1.next()) ***REMOVED***
            var tagString = tagStrings_1_1.value;
            var _b = __read(splitWithLimit(tagString, '=', 2), 2), tagName = _b[0], tagValue = _b[1];
            if (tagName === '') ***REMOVED***
                continue; // Ignore empty tags: @ @; @x; etc.
            ***REMOVED***
            // unescape according to http://ircv3.net/specs/core/message-tags-3.2.html#escaping-values
            tags.set(tagName, tagValue
                ? tagValue.replace(/\\(.?)/g, function (_, match) ***REMOVED***
                    return Object.prototype.hasOwnProperty.call(tagUnescapeMap, match) ? tagUnescapeMap[match] : match;
                ***REMOVED***)
                : '');
        ***REMOVED***
    ***REMOVED***
    catch (e_1_1) ***REMOVED*** e_1 = ***REMOVED*** error: e_1_1 ***REMOVED***; ***REMOVED***
    finally ***REMOVED***
        try ***REMOVED***
            if (tagStrings_1_1 && !tagStrings_1_1.done && (_a = tagStrings_1.return)) _a.call(tagStrings_1);
        ***REMOVED***
        finally ***REMOVED*** if (e_1) throw e_1.error; ***REMOVED***
    ***REMOVED***
    return tags;
***REMOVED***
export function parseMessage(line, serverProperties, knownCommands, isServer, nonConformingCommands) ***REMOVED***
    if (serverProperties === void 0) ***REMOVED*** serverProperties = defaultServerProperties; ***REMOVED***
    if (knownCommands === void 0) ***REMOVED*** knownCommands = coreMessageTypes; ***REMOVED***
    if (isServer === void 0) ***REMOVED*** isServer = false; ***REMOVED***
    if (nonConformingCommands === void 0) ***REMOVED*** nonConformingCommands = []; ***REMOVED***
    var splitLine = line.split(' ');
    // eslint-disable-next-line @typescript-eslint/init-declarations
    var token;
    // eslint-disable-next-line @typescript-eslint/init-declarations
    var command;
    var params = [];
    var tags = undefined;
    // eslint-disable-next-line @typescript-eslint/init-declarations
    var prefix;
    while (splitLine.length) ***REMOVED***
        token = splitLine[0];
        if (token.startsWith('@') && !tags && !command && !prefix) ***REMOVED***
            tags = parseTags(token.substr(1));
        ***REMOVED***
        else if (token.startsWith(':')) ***REMOVED***
            if (!prefix && !command) ***REMOVED***
                if (token.length > 1) ***REMOVED***
                    // Not an empty prefix
                    prefix = parsePrefix(token.substr(1));
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                params.push(***REMOVED***
                    value: splitLine.join(' ').substr(1),
                    trailing: true
                ***REMOVED***);
                break;
            ***REMOVED***
        ***REMOVED***
        else if (command) ***REMOVED***
            params.push(***REMOVED***
                value: token,
                trailing: false
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            command = token.toUpperCase();
        ***REMOVED***
        splitLine.shift();
    ***REMOVED***
    if (!tags) ***REMOVED***
        tags = new Map();
    ***REMOVED***
    if (!command) ***REMOVED***
        throw new Error("line without command received: " + line);
    ***REMOVED***
    var messageClass = Message;
    if (knownCommands.has(command)) ***REMOVED***
        messageClass = knownCommands.get(command);
    ***REMOVED***
    return new messageClass(command, params, tags, prefix, serverProperties, line, isServer, !nonConformingCommands.includes(command));
***REMOVED***
