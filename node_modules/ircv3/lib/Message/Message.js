"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
exports.Message = exports.createMessage = exports.prefixToString = void 0;
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var NotEnoughParametersError_1 = require("../Errors/NotEnoughParametersError");
var ParameterRequirementMismatchError_1 = require("../Errors/ParameterRequirementMismatchError");
var ServerProperties_1 = require("../ServerProperties");
var StringTools_1 = require("../Toolkit/StringTools");
var tagEscapeMap = ***REMOVED***
    '\\': '\\',
    ';': ':',
    '\n': 'n',
    '\r': 'r',
    ' ': 's'
***REMOVED***;
function escapeTag(str) ***REMOVED***
    return str.replace(/[\\;\n\r ]/g, function (match) ***REMOVED*** return "\\" + tagEscapeMap[match]; ***REMOVED***);
***REMOVED***
function prefixToString(prefix) ***REMOVED***
    var result = "" + prefix.nick;
    if (prefix.user) ***REMOVED***
        result += "!" + prefix.user;
    ***REMOVED***
    if (prefix.host) ***REMOVED***
        result += "@" + prefix.host;
    ***REMOVED***
    return result;
***REMOVED***
exports.prefixToString = prefixToString;
function createMessage(type, params, prefix, tags, serverProperties, isServer) ***REMOVED***
    if (serverProperties === void 0) ***REMOVED*** serverProperties = ServerProperties_1.defaultServerProperties; ***REMOVED***
    if (isServer === void 0) ***REMOVED*** isServer = false; ***REMOVED***
    var message = new type(type.COMMAND, undefined, undefined, undefined, serverProperties);
    var parsedParams = ***REMOVED******REMOVED***;
    shared_utils_1.forEachObjectEntry(type.PARAM_SPEC, function (paramSpec, paramName) ***REMOVED***
        if (isServer && paramSpec.noServer) ***REMOVED***
            return;
        ***REMOVED***
        if (!isServer && paramSpec.noClient) ***REMOVED***
            return;
        ***REMOVED***
        if (paramName in params) ***REMOVED***
            var param = params[paramName];
            if (param !== undefined) ***REMOVED***
                if (type.checkParam(param, paramSpec, serverProperties)) ***REMOVED***
                    parsedParams[paramName] = ***REMOVED***
                        value: param,
                        trailing: Boolean(paramSpec.trailing)
                    ***REMOVED***;
                ***REMOVED***
                else if (!paramSpec.optional) ***REMOVED***
                    throw new Error("required parameter \"" + paramName + "\" did not suit requirements: \"" + param + "\"");
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        if (!(paramName in parsedParams) && !paramSpec.optional) ***REMOVED***
            throw new Error("required parameter \"" + paramName + "\" not found in command \"" + type.COMMAND + "\"");
        ***REMOVED***
    ***REMOVED***);
    Object.assign(message, parsedParams);
    message._initPrefixAndTags(prefix, tags);
    return message;
***REMOVED***
exports.createMessage = createMessage;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var Message = /** @class */ (function () ***REMOVED***
    function Message(command, params, tags, prefix, serverProperties, rawLine, isServer, shouldParseParams) ***REMOVED***
        if (serverProperties === void 0) ***REMOVED*** serverProperties = ServerProperties_1.defaultServerProperties; ***REMOVED***
        if (isServer === void 0) ***REMOVED*** isServer = false; ***REMOVED***
        if (shouldParseParams === void 0) ***REMOVED*** shouldParseParams = true; ***REMOVED***
        this._params = [];
        this._serverProperties = ServerProperties_1.defaultServerProperties;
        this._command = command;
        this._params = params;
        this._tags = tags !== null && tags !== void 0 ? tags : new Map();
        this._prefix = prefix;
        this._serverProperties = serverProperties;
        this._raw = rawLine;
        if (shouldParseParams) ***REMOVED***
            this.parseParams(isServer);
        ***REMOVED***
    ***REMOVED***
    Message.checkParam = function (param, spec, serverProperties) ***REMOVED***
        if (serverProperties === void 0) ***REMOVED*** serverProperties = ServerProperties_1.defaultServerProperties; ***REMOVED***
        if (spec.type === 'channel') ***REMOVED***
            if (!StringTools_1.isChannel(param, serverProperties.channelTypes)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        if (spec.type === 'channelList') ***REMOVED***
            var channels = param.split(',');
            if (!channels.every(function (chan) ***REMOVED*** return StringTools_1.isChannel(chan, serverProperties.channelTypes); ***REMOVED***)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        if (spec.match) ***REMOVED***
            if (!spec.match.test(param)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        return true;
    ***REMOVED***;
    Message.getMinParamCount = function (isServer) ***REMOVED***
        if (isServer === void 0) ***REMOVED*** isServer = false; ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!this.PARAM_SPEC) ***REMOVED***
            return 0;
        ***REMOVED***
        return Object.values(this.PARAM_SPEC).filter(function (spec) ***REMOVED***
            if (spec.noServer && isServer) ***REMOVED***
                return false;
            ***REMOVED***
            if (spec.noClient && !isServer) ***REMOVED***
                return false;
            ***REMOVED***
            return !spec.optional;
        ***REMOVED***).length;
    ***REMOVED***;
    Message.prototype.prefixToString = function () ***REMOVED***
        if (!this._prefix) ***REMOVED***
            return '';
        ***REMOVED***
        return prefixToString(this._prefix);
    ***REMOVED***;
    Message.prototype.tagsToString = function () ***REMOVED***
        return tslib_1.__spread(this._tags.entries()).map(function (_a) ***REMOVED***
            var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
            return (value ? key + "=" + escapeTag(value) : key);
        ***REMOVED***).join(';');
    ***REMOVED***;
    Message.prototype.toString = function (includePrefix) ***REMOVED***
        var _this = this;
        if (includePrefix === void 0) ***REMOVED*** includePrefix = false; ***REMOVED***
        var cls = this.constructor;
        var specKeys = Object.keys(cls.PARAM_SPEC);
        var fullCommand = tslib_1.__spread([
            this._command
        ], specKeys
            .map(function (paramName) ***REMOVED***
            // TS inference does really not help here... so this is any for now
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var param = _this[paramName];
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (param) ***REMOVED***
                return (param.trailing ? ':' : '') + param.value;
            ***REMOVED***
            return undefined;
        ***REMOVED***)
            .filter(function (param) ***REMOVED*** return param !== undefined; ***REMOVED***)).join(' ');
        var parts = [fullCommand];
        if (includePrefix) ***REMOVED***
            var prefix = this.prefixToString();
            if (prefix) ***REMOVED***
                parts.unshift(":" + prefix);
            ***REMOVED***
        ***REMOVED***
        var tags = this.tagsToString();
        if (tags) ***REMOVED***
            parts.unshift("@" + tags);
        ***REMOVED***
        return parts.join(' ');
    ***REMOVED***;
    /** @private */
    Message.prototype._initPrefixAndTags = function (prefix, tags) ***REMOVED***
        this._prefix = prefix;
        if (tags) ***REMOVED***
            this._tags = tags;
        ***REMOVED***
    ***REMOVED***;
    Message.prototype.parseParams = function (isServer) ***REMOVED***
        var e_1, _a;
        if (isServer === void 0) ***REMOVED*** isServer = false; ***REMOVED***
        if (this._params) ***REMOVED***
            var cls = this.constructor;
            var requiredParamsLeft = cls.getMinParamCount(isServer);
            if (requiredParamsLeft > this._params.length) ***REMOVED***
                throw new NotEnoughParametersError_1.NotEnoughParametersError(this._command, requiredParamsLeft, this._params.length);
            ***REMOVED***
            var paramSpecList = cls.PARAM_SPEC;
            if (!paramSpecList) ***REMOVED***
                return;
            ***REMOVED***
            var i = 0;
            var parsedParams = ***REMOVED******REMOVED***;
            try ***REMOVED***
                for (var _b = tslib_1.__values(Object.entries(paramSpecList)), _c = _b.next(); !_c.done; _c = _b.next()) ***REMOVED***
                    var _d = tslib_1.__read(_c.value, 2), paramName = _d[0], paramSpec = _d[1];
                    if (paramSpec.noServer && isServer) ***REMOVED***
                        continue;
                    ***REMOVED***
                    if (paramSpec.noClient && !isServer) ***REMOVED***
                        continue;
                    ***REMOVED***
                    if (this._params.length - i <= requiredParamsLeft) ***REMOVED***
                        if (paramSpec.optional) ***REMOVED***
                            continue;
                        ***REMOVED***
                        else if (this._params.length - i !== requiredParamsLeft) ***REMOVED***
                            throw new Error('not enough parameters left for required parameters parsing (this is a library bug)');
                        ***REMOVED***
                    ***REMOVED***
                    var param = this._params[i];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (!param) ***REMOVED***
                        if (paramSpec.optional) ***REMOVED***
                            break;
                        ***REMOVED***
                        throw new Error('unexpected parameter underflow');
                    ***REMOVED***
                    if (paramSpec.rest) ***REMOVED***
                        var restParams = [];
                        while (this._params[i] && !this._params[i].trailing) ***REMOVED***
                            restParams.push(this._params[i].value);
                            ++i;
                        ***REMOVED***
                        if (!restParams.length) ***REMOVED***
                            if (paramSpec.optional) ***REMOVED***
                                continue;
                            ***REMOVED***
                            throw new Error("no parameters left for required rest parameter \"" + paramName + "\"");
                        ***REMOVED***
                        param = ***REMOVED***
                            value: restParams.join(' '),
                            trailing: false
                        ***REMOVED***;
                    ***REMOVED***
                    if (Message.checkParam(param.value, paramSpec)) ***REMOVED***
                        parsedParams[paramName] = tslib_1.__assign(***REMOVED******REMOVED***, param);
                        if (!paramSpec.optional) ***REMOVED***
                            --requiredParamsLeft;
                        ***REMOVED***
                        if (!paramSpec.rest) ***REMOVED***
                            ++i;
                        ***REMOVED***
                    ***REMOVED***
                    else if (!paramSpec.optional) ***REMOVED***
                        throw new ParameterRequirementMismatchError_1.ParameterRequirementMismatchError(this._command, paramName, paramSpec, param.value);
                    ***REMOVED***
                    if (paramSpec.trailing) ***REMOVED***
                        break;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            catch (e_1_1) ***REMOVED*** e_1 = ***REMOVED*** error: e_1_1 ***REMOVED***; ***REMOVED***
            finally ***REMOVED***
                try ***REMOVED***
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                ***REMOVED***
                finally ***REMOVED*** if (e_1) throw e_1.error; ***REMOVED***
            ***REMOVED***
            Object.assign(this, parsedParams);
        ***REMOVED***
    ***REMOVED***;
    Object.defineProperty(Message.prototype, "params", ***REMOVED***
        get: function () ***REMOVED***
            var _this = this;
            var cls = this.constructor;
            var specKeys = Object.keys(cls.PARAM_SPEC);
            return Object.assign.apply(Object, tslib_1.__spread([***REMOVED******REMOVED***], specKeys
                .map(function (paramName) ***REMOVED***
                // TS inference does really not help here... so this is any for now
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var param = _this[paramName];
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (param) ***REMOVED***
                    return [paramName, param.value];
                ***REMOVED***
                return undefined;
            ***REMOVED***)
                .filter(function (pair) ***REMOVED*** return pair !== undefined; ***REMOVED***)
                .map(function (_a) ***REMOVED***
                var _b;
                var _c = tslib_1.__read(_a, 2), key = _c[0], value = _c[1];
                return (_b = ***REMOVED******REMOVED***, _b[key] = value, _b);
            ***REMOVED***)));
    ***REMOVED***
        enumerable: false,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Message.prototype, "prefix", ***REMOVED***
        get: function () ***REMOVED***
            return this._prefix;
    ***REMOVED***
        enumerable: false,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Message.prototype, "command", ***REMOVED***
        get: function () ***REMOVED***
            return this._command;
    ***REMOVED***
        enumerable: false,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Message.prototype, "tags", ***REMOVED***
        get: function () ***REMOVED***
            return this._tags;
    ***REMOVED***
        enumerable: false,
        configurable: true
    ***REMOVED***);
    Object.defineProperty(Message.prototype, "rawLine", ***REMOVED***
        get: function () ***REMOVED***
            return this._raw;
    ***REMOVED***
        enumerable: false,
        configurable: true
    ***REMOVED***);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Message.prototype.isResponseTo = function (originalMessage) ***REMOVED***
        return false;
    ***REMOVED***;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Message.prototype.endsResponseTo = function (originalMessage) ***REMOVED***
        return false;
    ***REMOVED***;
    Message.prototype._acceptsInReplyCollection = function (message) ***REMOVED***
        // TODO implement IRCv3 labeled-response / batch here
        return message.isResponseTo(this);
    ***REMOVED***;
    Message.COMMAND = '';
    Message.SUPPORTS_CAPTURE = false;
    return Message;
***REMOVED***());
exports.Message = Message;
