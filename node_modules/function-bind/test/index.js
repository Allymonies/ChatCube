// jscs:disable requireUseStrict

var test = require('tape');

var functionBind = require('../implementation');
var getCurrentContext = function () ***REMOVED*** return this; ***REMOVED***;

test('functionBind is a function', function (t) ***REMOVED***
    t.equal(typeof functionBind, 'function');
    t.end();
***REMOVED***);

test('non-functions', function (t) ***REMOVED***
    var nonFunctions = [true, false, [], ***REMOVED******REMOVED***, 42, 'foo', NaN, /a/g];
    t.plan(nonFunctions.length);
    for (var i = 0; i < nonFunctions.length; ++i) ***REMOVED***
        try ***REMOVED*** functionBind.call(nonFunctions[i]); ***REMOVED*** catch (ex) ***REMOVED***
            t.ok(ex instanceof TypeError, 'throws when given ' + String(nonFunctions[i]));
        ***REMOVED***
    ***REMOVED***
    t.end();
***REMOVED***);

test('without a context', function (t) ***REMOVED***
    t.test('binds properly', function (st) ***REMOVED***
        var args, context;
        var namespace = ***REMOVED***
            func: functionBind.call(function () ***REMOVED***
                args = Array.prototype.slice.call(arguments);
                context = this;
            ***REMOVED***)
        ***REMOVED***;
        namespace.func(1, 2, 3);
        st.deepEqual(args, [1, 2, 3]);
        st.equal(context, getCurrentContext.call());
        st.end();
    ***REMOVED***);

    t.test('binds properly, and still supplies bound arguments', function (st) ***REMOVED***
        var args, context;
        var namespace = ***REMOVED***
            func: functionBind.call(function () ***REMOVED***
                args = Array.prototype.slice.call(arguments);
                context = this;
        ***REMOVED*** undefined, 1, 2, 3)
        ***REMOVED***;
        namespace.func(4, 5, 6);
        st.deepEqual(args, [1, 2, 3, 4, 5, 6]);
        st.equal(context, getCurrentContext.call());
        st.end();
    ***REMOVED***);

    t.test('returns properly', function (st) ***REMOVED***
        var args;
        var namespace = ***REMOVED***
            func: functionBind.call(function () ***REMOVED***
                args = Array.prototype.slice.call(arguments);
                return this;
        ***REMOVED*** null)
        ***REMOVED***;
        var context = namespace.func(1, 2, 3);
        st.equal(context, getCurrentContext.call(), 'returned context is namespaced context');
        st.deepEqual(args, [1, 2, 3], 'passed arguments are correct');
        st.end();
    ***REMOVED***);

    t.test('returns properly with bound arguments', function (st) ***REMOVED***
        var args;
        var namespace = ***REMOVED***
            func: functionBind.call(function () ***REMOVED***
                args = Array.prototype.slice.call(arguments);
                return this;
        ***REMOVED*** null, 1, 2, 3)
        ***REMOVED***;
        var context = namespace.func(4, 5, 6);
        st.equal(context, getCurrentContext.call(), 'returned context is namespaced context');
        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'passed arguments are correct');
        st.end();
    ***REMOVED***);

    t.test('called as a constructor', function (st) ***REMOVED***
        var thunkify = function (value) ***REMOVED***
            return function () ***REMOVED*** return value; ***REMOVED***;
        ***REMOVED***;
        st.test('returns object value', function (sst) ***REMOVED***
            var expectedReturnValue = [1, 2, 3];
            var Constructor = functionBind.call(thunkify(expectedReturnValue), null);
            var result = new Constructor();
            sst.equal(result, expectedReturnValue);
            sst.end();
        ***REMOVED***);

        st.test('does not return primitive value', function (sst) ***REMOVED***
            var Constructor = functionBind.call(thunkify(42), null);
            var result = new Constructor();
            sst.notEqual(result, 42);
            sst.end();
        ***REMOVED***);

        st.test('object from bound constructor is instance of original and bound constructor', function (sst) ***REMOVED***
            var A = function (x) ***REMOVED***
                this.name = x || 'A';
            ***REMOVED***;
            var B = functionBind.call(A, null, 'B');

            var result = new B();
            sst.ok(result instanceof B, 'result is instance of bound constructor');
            sst.ok(result instanceof A, 'result is instance of original constructor');
            sst.end();
        ***REMOVED***);

        st.end();
    ***REMOVED***);

    t.end();
***REMOVED***);

test('with a context', function (t) ***REMOVED***
    t.test('with no bound arguments', function (st) ***REMOVED***
        var args, context;
        var boundContext = ***REMOVED******REMOVED***;
        var namespace = ***REMOVED***
            func: functionBind.call(function () ***REMOVED***
                args = Array.prototype.slice.call(arguments);
                context = this;
        ***REMOVED*** boundContext)
        ***REMOVED***;
        namespace.func(1, 2, 3);
        st.equal(context, boundContext, 'binds a context properly');
        st.deepEqual(args, [1, 2, 3], 'supplies passed arguments');
        st.end();
    ***REMOVED***);

    t.test('with bound arguments', function (st) ***REMOVED***
        var args, context;
        var boundContext = ***REMOVED******REMOVED***;
        var namespace = ***REMOVED***
            func: functionBind.call(function () ***REMOVED***
                args = Array.prototype.slice.call(arguments);
                context = this;
        ***REMOVED*** boundContext, 1, 2, 3)
        ***REMOVED***;
        namespace.func(4, 5, 6);
        st.equal(context, boundContext, 'binds a context properly');
        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'supplies bound and passed arguments');
        st.end();
    ***REMOVED***);

    t.test('returns properly', function (st) ***REMOVED***
        var boundContext = ***REMOVED******REMOVED***;
        var args;
        var namespace = ***REMOVED***
            func: functionBind.call(function () ***REMOVED***
                args = Array.prototype.slice.call(arguments);
                return this;
        ***REMOVED*** boundContext)
        ***REMOVED***;
        var context = namespace.func(1, 2, 3);
        st.equal(context, boundContext, 'returned context is bound context');
        st.notEqual(context, getCurrentContext.call(), 'returned context is not lexical context');
        st.deepEqual(args, [1, 2, 3], 'passed arguments are correct');
        st.end();
    ***REMOVED***);

    t.test('returns properly with bound arguments', function (st) ***REMOVED***
        var boundContext = ***REMOVED******REMOVED***;
        var args;
        var namespace = ***REMOVED***
            func: functionBind.call(function () ***REMOVED***
                args = Array.prototype.slice.call(arguments);
                return this;
        ***REMOVED*** boundContext, 1, 2, 3)
        ***REMOVED***;
        var context = namespace.func(4, 5, 6);
        st.equal(context, boundContext, 'returned context is bound context');
        st.notEqual(context, getCurrentContext.call(), 'returned context is not lexical context');
        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'passed arguments are correct');
        st.end();
    ***REMOVED***);

    t.test('passes the correct arguments when called as a constructor', function (st) ***REMOVED***
        var expected = ***REMOVED*** name: 'Correct' ***REMOVED***;
        var namespace = ***REMOVED***
            Func: functionBind.call(function (arg) ***REMOVED***
                return arg;
        ***REMOVED*** ***REMOVED*** name: 'Incorrect' ***REMOVED***)
        ***REMOVED***;
        var returned = new namespace.Func(expected);
        st.equal(returned, expected, 'returns the right arg when called as a constructor');
        st.end();
    ***REMOVED***);

    t.test('has the new instance\'s context when called as a constructor', function (st) ***REMOVED***
        var actualContext;
        var expectedContext = ***REMOVED*** foo: 'bar' ***REMOVED***;
        var namespace = ***REMOVED***
            Func: functionBind.call(function () ***REMOVED***
                actualContext = this;
        ***REMOVED*** expectedContext)
        ***REMOVED***;
        var result = new namespace.Func();
        st.equal(result instanceof namespace.Func, true);
        st.notEqual(actualContext, expectedContext);
        st.end();
    ***REMOVED***);

    t.end();
***REMOVED***);

test('bound function length', function (t) ***REMOVED***
    t.test('sets a correct length without thisArg', function (st) ***REMOVED***
        var subject = functionBind.call(function (a, b, c) ***REMOVED*** return a + b + c; ***REMOVED***);
        st.equal(subject.length, 3);
        st.equal(subject(1, 2, 3), 6);
        st.end();
    ***REMOVED***);

    t.test('sets a correct length with thisArg', function (st) ***REMOVED***
        var subject = functionBind.call(function (a, b, c) ***REMOVED*** return a + b + c; ***REMOVED***, ***REMOVED******REMOVED***);
        st.equal(subject.length, 3);
        st.equal(subject(1, 2, 3), 6);
        st.end();
    ***REMOVED***);

    t.test('sets a correct length without thisArg and first argument', function (st) ***REMOVED***
        var subject = functionBind.call(function (a, b, c) ***REMOVED*** return a + b + c; ***REMOVED***, undefined, 1);
        st.equal(subject.length, 2);
        st.equal(subject(2, 3), 6);
        st.end();
    ***REMOVED***);

    t.test('sets a correct length with thisArg and first argument', function (st) ***REMOVED***
        var subject = functionBind.call(function (a, b, c) ***REMOVED*** return a + b + c; ***REMOVED***, ***REMOVED******REMOVED***, 1);
        st.equal(subject.length, 2);
        st.equal(subject(2, 3), 6);
        st.end();
    ***REMOVED***);

    t.test('sets a correct length without thisArg and too many arguments', function (st) ***REMOVED***
        var subject = functionBind.call(function (a, b, c) ***REMOVED*** return a + b + c; ***REMOVED***, undefined, 1, 2, 3, 4);
        st.equal(subject.length, 0);
        st.equal(subject(), 6);
        st.end();
    ***REMOVED***);

    t.test('sets a correct length with thisArg and too many arguments', function (st) ***REMOVED***
        var subject = functionBind.call(function (a, b, c) ***REMOVED*** return a + b + c; ***REMOVED***, ***REMOVED******REMOVED***, 1, 2, 3, 4);
        st.equal(subject.length, 0);
        st.equal(subject(), 6);
        st.end();
    ***REMOVED***);
***REMOVED***);
