'use strict';

var hasSymbols = require('has-symbols/shams')();
var forEach = require('for-each');
var has = require('has');

module.exports = function (assign, t) ***REMOVED***
	t.test('error cases', function (st) ***REMOVED***
		st['throws'](function () ***REMOVED*** assign(null); ***REMOVED***, TypeError, 'target must be an object');
		st['throws'](function () ***REMOVED*** assign(undefined); ***REMOVED***, TypeError, 'target must be an object');
		st['throws'](function () ***REMOVED*** assign(null, ***REMOVED******REMOVED***); ***REMOVED***, TypeError, 'target must be an object');
		st['throws'](function () ***REMOVED*** assign(undefined, ***REMOVED******REMOVED***); ***REMOVED***, TypeError, 'target must be an object');
		st.end();
	***REMOVED***);

	t.test('non-object target, no sources', function (st) ***REMOVED***
		var bool = assign(true);
		st.equal(typeof bool, 'object', 'bool is object');
		st.equal(Boolean.prototype.valueOf.call(bool), true, 'bool coerces to `true`');

		var number = assign(1);
		st.equal(typeof number, 'object', 'number is object');
		st.equal(Number.prototype.valueOf.call(number), 1, 'number coerces to `1`');

		var string = assign('1');
		st.equal(typeof string, 'object', 'number is object');
		st.equal(String.prototype.valueOf.call(string), '1', 'number coerces to `"1"`');

		st.end();
	***REMOVED***);

	t.test('non-object target, with sources', function (st) ***REMOVED***
		var signal = ***REMOVED******REMOVED***;

		st.test('boolean', function (st2) ***REMOVED***
			var bool = assign(true, ***REMOVED*** a: signal ***REMOVED***);
			st2.equal(typeof bool, 'object', 'bool is object');
			st2.equal(Boolean.prototype.valueOf.call(bool), true, 'bool coerces to `true`');
			st2.equal(bool.a, signal, 'source properties copied');
			st2.end();
		***REMOVED***);

		st.test('number', function (st2) ***REMOVED***
			var number = assign(1, ***REMOVED*** a: signal ***REMOVED***);
			st2.equal(typeof number, 'object', 'number is object');
			st2.equal(Number.prototype.valueOf.call(number), 1, 'number coerces to `1`');
			st2.equal(number.a, signal, 'source properties copied');
			st2.end();
		***REMOVED***);

		st.test('string', function (st2) ***REMOVED***
			var string = assign('1', ***REMOVED*** a: signal ***REMOVED***);
			st2.equal(typeof string, 'object', 'number is object');
			st2.equal(String.prototype.valueOf.call(string), '1', 'number coerces to `"1"`');
			st2.equal(string.a, signal, 'source properties copied');
			st2.end();
		***REMOVED***);

		st.end();
	***REMOVED***);

	t.test('non-object sources', function (st) ***REMOVED***
		st.deepEqual(assign(***REMOVED*** a: 1 ***REMOVED***, null, ***REMOVED*** b: 2 ***REMOVED***), ***REMOVED*** a: 1, b: 2 ***REMOVED***, 'ignores null source');
		st.deepEqual(assign(***REMOVED*** a: 1 ***REMOVED***, ***REMOVED*** b: 2 ***REMOVED***, undefined), ***REMOVED*** a: 1, b: 2 ***REMOVED***, 'ignores undefined source');
		st.end();
	***REMOVED***);

	t.test('returns the modified target object', function (st) ***REMOVED***
		var target = ***REMOVED******REMOVED***;
		var returned = assign(target, ***REMOVED*** a: 1 ***REMOVED***);
		st.equal(returned, target, 'returned object is the same reference as the target object');
		st.end();
	***REMOVED***);

	t.test('has the right length', function (st) ***REMOVED***
		st.equal(assign.length, 2, 'length is 2 => 2 required arguments');
		st.end();
	***REMOVED***);

	t.test('merge two objects', function (st) ***REMOVED***
		var target = ***REMOVED*** a: 1 ***REMOVED***;
		var returned = assign(target, ***REMOVED*** b: 2 ***REMOVED***);
		st.deepEqual(returned, ***REMOVED*** a: 1, b: 2 ***REMOVED***, 'returned object has properties from both');
		st.end();
	***REMOVED***);

	t.test('works with functions', function (st) ***REMOVED***
		var target = function () ***REMOVED******REMOVED***;
		target.a = 1;
		var returned = assign(target, ***REMOVED*** b: 2 ***REMOVED***);
		st.equal(target, returned, 'returned object is target');
		st.equal(returned.a, 1);
		st.equal(returned.b, 2);
		st.end();
	***REMOVED***);

	t.test('works with primitives', function (st) ***REMOVED***
		var target = 2;
		var source = ***REMOVED*** b: 42 ***REMOVED***;
		var returned = assign(target, source);
		st.equal(Object.prototype.toString.call(returned), '[object Number]', 'returned is object form of number primitive');
		st.equal(Number(returned), target, 'returned and target have same valueOf');
		st.equal(returned.b, source.b);
		st.end();
	***REMOVED***);

	/* globals window */
	t.test('works with window.location', ***REMOVED*** skip: typeof window === 'undefined' ***REMOVED***, function (st) ***REMOVED***
		var target = ***REMOVED******REMOVED***;
		assign(target, window.location);
		for (var prop in window.location) ***REMOVED***
			if (has(window.location, prop)) ***REMOVED***
				st.deepEqual(target[prop], window.location[prop], prop + ' is copied');
			***REMOVED***
		***REMOVED***
		st.end();
	***REMOVED***);

	t.test('merge N objects', function (st) ***REMOVED***
		var target = ***REMOVED*** a: 1 ***REMOVED***;
		var source1 = ***REMOVED*** b: 2 ***REMOVED***;
		var source2 = ***REMOVED*** c: 3 ***REMOVED***;
		var returned = assign(target, source1, source2);
		st.deepEqual(returned, ***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, 'returned object has properties from all sources');
		st.end();
	***REMOVED***);

	t.test('only iterates over own keys', function (st) ***REMOVED***
		var Foo = function () ***REMOVED******REMOVED***;
		Foo.prototype.bar = true;
		var foo = new Foo();
		foo.baz = true;
		var target = ***REMOVED*** a: 1 ***REMOVED***;
		var returned = assign(target, foo);
		st.equal(returned, target, 'returned object is the same reference as the target object');
		st.deepEqual(target, ***REMOVED*** a: 1, baz: true ***REMOVED***, 'returned object has only own properties from both');
		st.end();
	***REMOVED***);

	t.test('includes enumerable symbols, after keys', ***REMOVED*** skip: !hasSymbols ***REMOVED***, function (st) ***REMOVED***
		var visited = [];
		var obj = ***REMOVED******REMOVED***;
		Object.defineProperty(obj, 'a', ***REMOVED*** enumerable: true, get: function () ***REMOVED*** visited.push('a'); return 42; ***REMOVED*** ***REMOVED***);
		var symbol = Symbol('enumerable');
		Object.defineProperty(obj, symbol, ***REMOVED***
			enumerable: true,
			get: function () ***REMOVED*** visited.push(symbol); return Infinity; ***REMOVED***
		***REMOVED***);
		var nonEnumSymbol = Symbol('non-enumerable');
		Object.defineProperty(obj, nonEnumSymbol, ***REMOVED***
			enumerable: false,
			get: function () ***REMOVED*** visited.push(nonEnumSymbol); return -Infinity; ***REMOVED***
		***REMOVED***);
		var target = assign(***REMOVED******REMOVED***, obj);
		st.deepEqual(visited, ['a', symbol], 'key is visited first, then symbol');
		st.equal(target.a, 42, 'target.a is 42');
		st.equal(target[symbol], Infinity, 'target[symbol] is Infinity');
		st.notEqual(target[nonEnumSymbol], -Infinity, 'target[nonEnumSymbol] is not -Infinity');
		st.end();
	***REMOVED***);

	t.test('does not fail when symbols are not present', ***REMOVED*** skip: !Object.isFrozen || Object.isFrozen(Object) ***REMOVED***, function (st) ***REMOVED***
		var getSyms;
		if (hasSymbols) ***REMOVED***
			getSyms = Object.getOwnPropertySymbols;
			delete Object.getOwnPropertySymbols;
		***REMOVED***

		var visited = [];
		var obj = ***REMOVED******REMOVED***;
		Object.defineProperty(obj, 'a', ***REMOVED*** enumerable: true, get: function () ***REMOVED*** visited.push('a'); return 42; ***REMOVED*** ***REMOVED***);
		var keys = ['a'];
		if (hasSymbols) ***REMOVED***
			var symbol = Symbol('sym');
			Object.defineProperty(obj, symbol, ***REMOVED***
				enumerable: true,
				get: function () ***REMOVED*** visited.push(symbol); return Infinity; ***REMOVED***
			***REMOVED***);
			keys.push(symbol);
		***REMOVED***
		var target = assign(***REMOVED******REMOVED***, obj);
		st.deepEqual(visited, keys, 'assign visits expected keys');
		st.equal(target.a, 42, 'target.a is 42');

		if (hasSymbols) ***REMOVED***
			st.equal(target[symbol], Infinity);

			Object.getOwnPropertySymbols = getSyms;
		***REMOVED***
		st.end();
	***REMOVED***);

	t.test('preserves correct property enumeration order', function (st) ***REMOVED***
		var str = 'abcdefghijklmnopqrst';
		var letters = ***REMOVED******REMOVED***;
		forEach(str.split(''), function (letter) ***REMOVED***
			letters[letter] = letter;
		***REMOVED***);

		var n = 5;
		st.comment('run the next test ' + n + ' times');
		var object = assign(***REMOVED******REMOVED***, letters);
		var actual = '';
		for (var k in object) ***REMOVED***
			actual += k;
		***REMOVED***
		for (var i = 0; i < n; ++i) ***REMOVED***
			st.equal(actual, str, 'property enumeration order should be followed');
		***REMOVED***
		st.end();
	***REMOVED***);

	t.test('checks enumerability and existence, in case of modification during [[Get]]', ***REMOVED*** skip: !Object.defineProperty ***REMOVED***, function (st) ***REMOVED***
		var targetBvalue = ***REMOVED******REMOVED***;
		var targetCvalue = ***REMOVED******REMOVED***;
		var target = ***REMOVED*** b: targetBvalue, c: targetCvalue ***REMOVED***;
		var source = ***REMOVED******REMOVED***;
		Object.defineProperty(source, 'a', ***REMOVED***
			enumerable: true,
			get: function () ***REMOVED***
				delete this.b;
				Object.defineProperty(this, 'c', ***REMOVED*** enumerable: false ***REMOVED***);
				return 'a';
			***REMOVED***
		***REMOVED***);
		var sourceBvalue = ***REMOVED******REMOVED***;
		var sourceCvalue = ***REMOVED******REMOVED***;
		source.b = sourceBvalue;
		source.c = sourceCvalue;
		var result = assign(target, source);
		st.equal(result, target, 'sanity check: result is === target');
		st.equal(result.b, targetBvalue, 'target key not overwritten by deleted source key');
		st.equal(result.c, targetCvalue, 'target key not overwritten by non-enumerable source key');

		st.end();
	***REMOVED***);
***REMOVED***;
