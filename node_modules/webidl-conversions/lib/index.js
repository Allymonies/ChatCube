"use strict";

var conversions = ***REMOVED******REMOVED***;
module.exports = conversions;

function sign(x) ***REMOVED***
    return x < 0 ? -1 : 1;
***REMOVED***

function evenRound(x) ***REMOVED***
    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.
    if ((x % 1) === 0.5 && (x & 1) === 0) ***REMOVED*** // [even number].5; round down (i.e. floor)
        return Math.floor(x);
    ***REMOVED*** else ***REMOVED***
        return Math.round(x);
    ***REMOVED***
***REMOVED***

function createNumberConversion(bitLength, typeOpts) ***REMOVED***
    if (!typeOpts.unsigned) ***REMOVED***
        --bitLength;
    ***REMOVED***
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;

    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);

    return function(V, opts) ***REMOVED***
        if (!opts) opts = ***REMOVED******REMOVED***;

        let x = +V;

        if (opts.enforceRange) ***REMOVED***
            if (!Number.isFinite(x)) ***REMOVED***
                throw new TypeError("Argument is not a finite number");
            ***REMOVED***

            x = sign(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) ***REMOVED***
                throw new TypeError("Argument is not in byte range");
            ***REMOVED***

            return x;
        ***REMOVED***

        if (!isNaN(x) && opts.clamp) ***REMOVED***
            x = evenRound(x);

            if (x < lowerBound) x = lowerBound;
            if (x > upperBound) x = upperBound;
            return x;
        ***REMOVED***

        if (!Number.isFinite(x) || x === 0) ***REMOVED***
            return 0;
        ***REMOVED***

        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;

        if (!typeOpts.unsigned && x >= moduloBound) ***REMOVED***
            return x - moduloVal;
        ***REMOVED*** else if (typeOpts.unsigned) ***REMOVED***
            if (x < 0) ***REMOVED***
              x += moduloVal;
            ***REMOVED*** else if (x === -0) ***REMOVED*** // don't return negative zero
              return 0;
            ***REMOVED***
        ***REMOVED***

        return x;
    ***REMOVED***
***REMOVED***

conversions["void"] = function () ***REMOVED***
    return undefined;
***REMOVED***;

conversions["boolean"] = function (val) ***REMOVED***
    return !!val;
***REMOVED***;

conversions["byte"] = createNumberConversion(8, ***REMOVED*** unsigned: false ***REMOVED***);
conversions["octet"] = createNumberConversion(8, ***REMOVED*** unsigned: true ***REMOVED***);

conversions["short"] = createNumberConversion(16, ***REMOVED*** unsigned: false ***REMOVED***);
conversions["unsigned short"] = createNumberConversion(16, ***REMOVED*** unsigned: true ***REMOVED***);

conversions["long"] = createNumberConversion(32, ***REMOVED*** unsigned: false ***REMOVED***);
conversions["unsigned long"] = createNumberConversion(32, ***REMOVED*** unsigned: true ***REMOVED***);

conversions["long long"] = createNumberConversion(32, ***REMOVED*** unsigned: false, moduloBitLength: 64 ***REMOVED***);
conversions["unsigned long long"] = createNumberConversion(32, ***REMOVED*** unsigned: true, moduloBitLength: 64 ***REMOVED***);

conversions["double"] = function (V) ***REMOVED***
    const x = +V;

    if (!Number.isFinite(x)) ***REMOVED***
        throw new TypeError("Argument is not a finite floating-point value");
    ***REMOVED***

    return x;
***REMOVED***;

conversions["unrestricted double"] = function (V) ***REMOVED***
    const x = +V;

    if (isNaN(x)) ***REMOVED***
        throw new TypeError("Argument is NaN");
    ***REMOVED***

    return x;
***REMOVED***;

// not quite valid, but good enough for JS
conversions["float"] = conversions["double"];
conversions["unrestricted float"] = conversions["unrestricted double"];

conversions["DOMString"] = function (V, opts) ***REMOVED***
    if (!opts) opts = ***REMOVED******REMOVED***;

    if (opts.treatNullAsEmptyString && V === null) ***REMOVED***
        return "";
    ***REMOVED***

    return String(V);
***REMOVED***;

conversions["ByteString"] = function (V, opts) ***REMOVED***
    const x = String(V);
    let c = undefined;
    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) ***REMOVED***
        if (c > 255) ***REMOVED***
            throw new TypeError("Argument is not a valid bytestring");
        ***REMOVED***
    ***REMOVED***

    return x;
***REMOVED***;

conversions["USVString"] = function (V) ***REMOVED***
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i = 0; i < n; ++i) ***REMOVED***
        const c = S.charCodeAt(i);
        if (c < 0xD800 || c > 0xDFFF) ***REMOVED***
            U.push(String.fromCodePoint(c));
        ***REMOVED*** else if (0xDC00 <= c && c <= 0xDFFF) ***REMOVED***
            U.push(String.fromCodePoint(0xFFFD));
        ***REMOVED*** else ***REMOVED***
            if (i === n - 1) ***REMOVED***
                U.push(String.fromCodePoint(0xFFFD));
            ***REMOVED*** else ***REMOVED***
                const d = S.charCodeAt(i + 1);
                if (0xDC00 <= d && d <= 0xDFFF) ***REMOVED***
                    const a = c & 0x3FF;
                    const b = d & 0x3FF;
                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                    ++i;
                ***REMOVED*** else ***REMOVED***
                    U.push(String.fromCodePoint(0xFFFD));
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return U.join('');
***REMOVED***;

conversions["Date"] = function (V, opts) ***REMOVED***
    if (!(V instanceof Date)) ***REMOVED***
        throw new TypeError("Argument is not a Date object");
    ***REMOVED***
    if (isNaN(V)) ***REMOVED***
        return undefined;
    ***REMOVED***

    return V;
***REMOVED***;

conversions["RegExp"] = function (V, opts) ***REMOVED***
    if (!(V instanceof RegExp)) ***REMOVED***
        V = new RegExp(V);
    ***REMOVED***

    return V;
***REMOVED***;
