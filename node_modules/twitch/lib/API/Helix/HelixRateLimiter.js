"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
exports.HelixRateLimiter = void 0;
var tslib_1 = require("tslib");
var rate_limiter_1 = require("@d-fischer/rate-limiter");
var twitch_api_call_1 = require("twitch-api-call");
/** @private */
var HelixRateLimiter = /** @class */ (function (_super) ***REMOVED***
    tslib_1.__extends(HelixRateLimiter, _super);
    function HelixRateLimiter() ***REMOVED***
        return _super !== null && _super.apply(this, arguments) || this;
    ***REMOVED***
    HelixRateLimiter.prototype.doRequest = function (_a) ***REMOVED***
        var options = _a.options, clientId = _a.clientId, accessToken = _a.accessToken, fetchOptions = _a.fetchOptions;
        return tslib_1.__awaiter(this, void 0, void 0, function () ***REMOVED***
            return tslib_1.__generator(this, function (_b) ***REMOVED***
                return [2 /*return*/, twitch_api_call_1.callTwitchApiRaw(options, clientId, accessToken, fetchOptions)];
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    HelixRateLimiter.prototype.needsToRetryAfter = function (res) ***REMOVED***
        if (res.status === 429) ***REMOVED***
            return +res.headers.get('ratelimit-reset') * 1000 - Date.now();
        ***REMOVED***
        return null;
    ***REMOVED***;
    HelixRateLimiter.prototype.getParametersFromResponse = function (res) ***REMOVED***
        var headers = res.headers;
        return ***REMOVED***
            limit: +headers.get('ratelimit-limit'),
            remaining: +headers.get('ratelimit-remaining'),
            resetsAt: +headers.get('ratelimit-reset') * 1000
        ***REMOVED***;
    ***REMOVED***;
    return HelixRateLimiter;
***REMOVED***(rate_limiter_1.ResponseBasedRateLimiter));
exports.HelixRateLimiter = HelixRateLimiter;
