import ***REMOVED*** __awaiter, __extends, __generator ***REMOVED*** from "tslib";
import ***REMOVED*** ResponseBasedRateLimiter ***REMOVED*** from '@d-fischer/rate-limiter';
import ***REMOVED*** callTwitchApiRaw ***REMOVED*** from 'twitch-api-call';
/** @private */
var HelixRateLimiter = /** @class */ (function (_super) ***REMOVED***
    __extends(HelixRateLimiter, _super);
    function HelixRateLimiter() ***REMOVED***
        return _super !== null && _super.apply(this, arguments) || this;
    ***REMOVED***
    HelixRateLimiter.prototype.doRequest = function (_a) ***REMOVED***
        var options = _a.options, clientId = _a.clientId, accessToken = _a.accessToken, fetchOptions = _a.fetchOptions;
        return __awaiter(this, void 0, Promise, function () ***REMOVED***
            return __generator(this, function (_b) ***REMOVED***
                return [2 /*return*/, callTwitchApiRaw(options, clientId, accessToken, fetchOptions)];
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    HelixRateLimiter.prototype.needsToRetryAfter = function (res) ***REMOVED***
        if (res.status === 429) ***REMOVED***
            return +res.headers.get('ratelimit-reset') * 1000 - Date.now();
        ***REMOVED***
        return null;
    ***REMOVED***;
    HelixRateLimiter.prototype.getParametersFromResponse = function (res) ***REMOVED***
        var headers = res.headers;
        return ***REMOVED***
            limit: +headers.get('ratelimit-limit'),
            remaining: +headers.get('ratelimit-remaining'),
            resetsAt: +headers.get('ratelimit-reset') * 1000
        ***REMOVED***;
    ***REMOVED***;
    return HelixRateLimiter;
***REMOVED***(ResponseBasedRateLimiter));
export ***REMOVED*** HelixRateLimiter ***REMOVED***;
