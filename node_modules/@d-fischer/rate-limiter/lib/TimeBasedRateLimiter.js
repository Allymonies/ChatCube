"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
exports.TimeBasedRateLimiter = void 0;
var tslib_1 = require("tslib");
var logger_1 = require("@d-fischer/logger");
var TimeBasedRateLimiter = /** @class */ (function () ***REMOVED***
    function TimeBasedRateLimiter(_a) ***REMOVED***
        var logger = _a.logger, bucketSize = _a.bucketSize, timeFrame = _a.timeFrame, doRequest = _a.doRequest;
        this._queue = [];
        this._usedFromBucket = 0;
        this._logger = logger_1.createLogger(tslib_1.__assign(***REMOVED*** name: 'rate-limiter', emoji: true ***REMOVED***, logger));
        this._bucketSize = bucketSize;
        this._timeFrame = timeFrame;
        this._callback = doRequest;
    ***REMOVED***
    TimeBasedRateLimiter.prototype.request = function (req) ***REMOVED***
        return tslib_1.__awaiter(this, void 0, void 0, function () ***REMOVED***
            var _this = this;
            return tslib_1.__generator(this, function (_a) ***REMOVED***
                return [2 /*return*/, new Promise(function (resolve, reject) ***REMOVED***
                        var reqSpec = ***REMOVED***
                            req: req,
                            resolve: resolve,
                            reject: reject
                        ***REMOVED***;
                        if (_this._usedFromBucket >= _this._bucketSize) ***REMOVED***
                            _this._queue.push(reqSpec);
                            _this._logger.warn("Rate limit of " + _this._bucketSize + " was reached, waiting for a free bucket entry; queue size is " + _this._queue.length);
                        ***REMOVED***
                        else ***REMOVED***
                            void _this._runRequest(reqSpec);
                        ***REMOVED***
                    ***REMOVED***)];
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    TimeBasedRateLimiter.prototype._runRequest = function (reqSpec) ***REMOVED***
        return tslib_1.__awaiter(this, void 0, void 0, function () ***REMOVED***
            var req, resolve, reject, _a, e_1;
            var _this = this;
            return tslib_1.__generator(this, function (_b) ***REMOVED***
                switch (_b.label) ***REMOVED***
                    case 0:
                        this._logger.debug("doing a request, new queue length is " + this._queue.length);
                        this._usedFromBucket += 1;
                        req = reqSpec.req, resolve = reqSpec.resolve, reject = reqSpec.reject;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        _a = resolve;
                        return [4 /*yield*/, this._callback(req)];
                    case 2:
                        _a.apply(void 0, [_b.sent()]);
                        return [3 /*break*/, 5];
                    case 3:
                        e_1 = _b.sent();
                        reject(e_1);
                        return [3 /*break*/, 5];
                    case 4:
                        setTimeout(function () ***REMOVED***
                            _this._usedFromBucket -= 1;
                            if (_this._queue.length && _this._usedFromBucket < _this._bucketSize) ***REMOVED***
                                _this._runNextRequest();
                            ***REMOVED***
                    ***REMOVED*** this._timeFrame);
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    TimeBasedRateLimiter.prototype._runNextRequest = function () ***REMOVED***
        var reqSpec = this._queue.shift();
        if (reqSpec) ***REMOVED***
            void this._runRequest(reqSpec);
        ***REMOVED***
    ***REMOVED***;
    return TimeBasedRateLimiter;
***REMOVED***());
exports.TimeBasedRateLimiter = TimeBasedRateLimiter;
//# sourceMappingURL=TimeBasedRateLimiter.js.map