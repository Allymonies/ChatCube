import ***REMOVED*** __assign, __awaiter, __generator ***REMOVED*** from "tslib";
import ***REMOVED*** createLogger ***REMOVED*** from '@d-fischer/logger';
var PartitionedTimeBasedRateLimiter = /** @class */ (function () ***REMOVED***
    function PartitionedTimeBasedRateLimiter(_a) ***REMOVED***
        var logger = _a.logger, bucketSize = _a.bucketSize, timeFrame = _a.timeFrame, doRequest = _a.doRequest, getPartitionKey = _a.getPartitionKey;
        this._partitionedQueue = new Map();
        this._usedFromBucket = new Map();
        this._logger = createLogger(__assign(***REMOVED*** name: 'rate-limiter', emoji: true ***REMOVED***, logger));
        this._bucketSize = bucketSize;
        this._timeFrame = timeFrame;
        this._callback = doRequest;
        this._partitionKeyCallback = getPartitionKey;
    ***REMOVED***
    PartitionedTimeBasedRateLimiter.prototype.request = function (req) ***REMOVED***
        return __awaiter(this, void 0, Promise, function () ***REMOVED***
            var _this = this;
            return __generator(this, function (_a) ***REMOVED***
                return [2 /*return*/, new Promise(function (resolve, reject) ***REMOVED***
                        var _a;
                        var reqSpec = ***REMOVED***
                            req: req,
                            resolve: resolve,
                            reject: reject
                        ***REMOVED***;
                        var partitionKey = _this._partitionKeyCallback(req);
                        var usedFromBucket = (_a = _this._usedFromBucket.get(partitionKey)) !== null && _a !== void 0 ? _a : 0;
                        if (usedFromBucket >= _this._bucketSize) ***REMOVED***
                            var queue = _this._getPartitionedQueue(partitionKey);
                            queue.push(reqSpec);
                            _this._logger.warn("Rate limit of " + _this._bucketSize + " for partition " + partitionKey + " was reached, waiting for a free bucket entry; queue size is " + queue.length);
                        ***REMOVED***
                        else ***REMOVED***
                            void _this._runRequest(reqSpec, partitionKey);
                        ***REMOVED***
                    ***REMOVED***)];
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    PartitionedTimeBasedRateLimiter.prototype._getPartitionedQueue = function (partitionKey) ***REMOVED***
        if (this._partitionedQueue.has(partitionKey)) ***REMOVED***
            return this._partitionedQueue.get(partitionKey);
        ***REMOVED***
        var newQueue = [];
        this._partitionedQueue.set(partitionKey, newQueue);
        return newQueue;
    ***REMOVED***;
    PartitionedTimeBasedRateLimiter.prototype._runRequest = function (reqSpec, partitionKey) ***REMOVED***
        var _a;
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var queue, req, resolve, reject, _b, e_1;
            var _this = this;
            return __generator(this, function (_c) ***REMOVED***
                switch (_c.label) ***REMOVED***
                    case 0:
                        queue = this._getPartitionedQueue(partitionKey);
                        this._logger.debug("doing a request for partiton " + partitionKey + ", new queue length is " + queue.length);
                        this._usedFromBucket.set(partitionKey, ((_a = this._usedFromBucket.get(partitionKey)) !== null && _a !== void 0 ? _a : 0) + 1);
                        req = reqSpec.req, resolve = reqSpec.resolve, reject = reqSpec.reject;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, 4, 5]);
                        _b = resolve;
                        return [4 /*yield*/, this._callback(req)];
                    case 2:
                        _b.apply(void 0, [_c.sent()]);
                        return [3 /*break*/, 5];
                    case 3:
                        e_1 = _c.sent();
                        reject(e_1);
                        return [3 /*break*/, 5];
                    case 4:
                        setTimeout(function () ***REMOVED***
                            var newUsed = _this._usedFromBucket.get(partitionKey) - 1;
                            _this._usedFromBucket.set(partitionKey, newUsed);
                            if (queue.length && newUsed < _this._bucketSize) ***REMOVED***
                                _this._runNextRequest(partitionKey);
                            ***REMOVED***
                    ***REMOVED*** this._timeFrame);
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***;
    PartitionedTimeBasedRateLimiter.prototype._runNextRequest = function (partitionKey) ***REMOVED***
        var queue = this._getPartitionedQueue(partitionKey);
        var reqSpec = queue.shift();
        if (reqSpec) ***REMOVED***
            void this._runRequest(reqSpec, partitionKey);
        ***REMOVED***
    ***REMOVED***;
    return PartitionedTimeBasedRateLimiter;
***REMOVED***());
export ***REMOVED*** PartitionedTimeBasedRateLimiter ***REMOVED***;
//# sourceMappingURL=PartitionedTimeBasedRateLimiter.mjs.map