'use strict';

var test = require('tape');
var qs = require('../');
var utils = require('../lib/utils');
var iconv = require('iconv-lite');
var SaferBuffer = require('safer-buffer').Buffer;
var hasSymbols = require('has-symbols');
var hasBigInt = typeof BigInt === 'function';

test('stringify()', function (t) ***REMOVED***
    t.test('stringifies a querystring object', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b' ***REMOVED***), 'a=b');
        st.equal(qs.stringify(***REMOVED*** a: 1 ***REMOVED***), 'a=1');
        st.equal(qs.stringify(***REMOVED*** a: 1, b: 2 ***REMOVED***), 'a=1&b=2');
        st.equal(qs.stringify(***REMOVED*** a: 'A_Z' ***REMOVED***), 'a=A_Z');
        st.equal(qs.stringify(***REMOVED*** a: 'â‚¬' ***REMOVED***), 'a=%E2%82%AC');
        st.equal(qs.stringify(***REMOVED*** a: 'î€€' ***REMOVED***), 'a=%EE%80%80');
        st.equal(qs.stringify(***REMOVED*** a: '×' ***REMOVED***), 'a=%D7%90');
        st.equal(qs.stringify(***REMOVED*** a: 'ð·' ***REMOVED***), 'a=%F0%90%90%B7');
        st.end();
    ***REMOVED***);

    t.test('stringifies falsy values', function (st) ***REMOVED***
        st.equal(qs.stringify(undefined), '');
        st.equal(qs.stringify(null), '');
        st.equal(qs.stringify(null, ***REMOVED*** strictNullHandling: true ***REMOVED***), '');
        st.equal(qs.stringify(false), '');
        st.equal(qs.stringify(0), '');
        st.end();
    ***REMOVED***);

    t.test('stringifies symbols', ***REMOVED*** skip: !hasSymbols() ***REMOVED***, function (st) ***REMOVED***
        st.equal(qs.stringify(Symbol.iterator), '');
        st.equal(qs.stringify([Symbol.iterator]), '0=Symbol%28Symbol.iterator%29');
        st.equal(qs.stringify(***REMOVED*** a: Symbol.iterator ***REMOVED***), 'a=Symbol%28Symbol.iterator%29');
        st.equal(
            qs.stringify(***REMOVED*** a: [Symbol.iterator] ***REMOVED***, ***REMOVED*** encodeValuesOnly: true, arrayFormat: 'brackets' ***REMOVED***),
            'a[]=Symbol%28Symbol.iterator%29'
        );
        st.end();
    ***REMOVED***);

    t.test('stringifies bigints', ***REMOVED*** skip: !hasBigInt ***REMOVED***, function (st) ***REMOVED***
        var three = BigInt(3);
        var encodeWithN = function (value, defaultEncoder, charset) ***REMOVED***
            var result = defaultEncoder(value, defaultEncoder, charset);
            return typeof value === 'bigint' ? result + 'n' : result;
        ***REMOVED***;
        st.equal(qs.stringify(three), '');
        st.equal(qs.stringify([three]), '0=3');
        st.equal(qs.stringify([three], ***REMOVED*** encoder: encodeWithN ***REMOVED***), '0=3n');
        st.equal(qs.stringify(***REMOVED*** a: three ***REMOVED***), 'a=3');
        st.equal(qs.stringify(***REMOVED*** a: three ***REMOVED***, ***REMOVED*** encoder: encodeWithN ***REMOVED***), 'a=3n');
        st.equal(
            qs.stringify(***REMOVED*** a: [three] ***REMOVED***, ***REMOVED*** encodeValuesOnly: true, arrayFormat: 'brackets' ***REMOVED***),
            'a[]=3'
        );
        st.equal(
            qs.stringify(***REMOVED*** a: [three] ***REMOVED***, ***REMOVED*** encodeValuesOnly: true, encoder: encodeWithN, arrayFormat: 'brackets' ***REMOVED***),
            'a[]=3n'
        );
        st.end();
    ***REMOVED***);

    t.test('adds query prefix', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b' ***REMOVED***, ***REMOVED*** addQueryPrefix: true ***REMOVED***), '?a=b');
        st.end();
    ***REMOVED***);

    t.test('with query prefix, outputs blank string given an empty object', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED******REMOVED***, ***REMOVED*** addQueryPrefix: true ***REMOVED***), '');
        st.end();
    ***REMOVED***);

    t.test('stringifies nested falsy values', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: null ***REMOVED*** ***REMOVED*** ***REMOVED***), 'a%5Bb%5D%5Bc%5D=');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: null ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** strictNullHandling: true ***REMOVED***), 'a%5Bb%5D%5Bc%5D');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: false ***REMOVED*** ***REMOVED*** ***REMOVED***), 'a%5Bb%5D%5Bc%5D=false');
        st.end();
    ***REMOVED***);

    t.test('stringifies a nested object', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=c');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: ***REMOVED*** d: 'e' ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***), 'a%5Bb%5D%5Bc%5D%5Bd%5D=e');
        st.end();
    ***REMOVED***);

    t.test('stringifies a nested object with dots notation', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***, ***REMOVED*** allowDots: true ***REMOVED***), 'a.b=c');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ***REMOVED*** c: ***REMOVED*** d: 'e' ***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***, ***REMOVED*** allowDots: true ***REMOVED***), 'a.b.c.d=e');
        st.end();
    ***REMOVED***);

    t.test('stringifies an array value', function (st) ***REMOVED***
        st.equal(
            qs.stringify(***REMOVED*** a: ['b', 'c', 'd'] ***REMOVED***, ***REMOVED*** arrayFormat: 'indices' ***REMOVED***),
            'a%5B0%5D=b&a%5B1%5D=c&a%5B2%5D=d',
            'indices => indices'
        );
        st.equal(
            qs.stringify(***REMOVED*** a: ['b', 'c', 'd'] ***REMOVED***, ***REMOVED*** arrayFormat: 'brackets' ***REMOVED***),
            'a%5B%5D=b&a%5B%5D=c&a%5B%5D=d',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify(***REMOVED*** a: ['b', 'c', 'd'] ***REMOVED***, ***REMOVED*** arrayFormat: 'comma' ***REMOVED***),
            'a=b%2Cc%2Cd',
            'comma => comma'
        );
        st.equal(
            qs.stringify(***REMOVED*** a: ['b', 'c', 'd'] ***REMOVED***),
            'a%5B0%5D=b&a%5B1%5D=c&a%5B2%5D=d',
            'default => indices'
        );
        st.end();
    ***REMOVED***);

    t.test('omits nulls when asked', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b', c: null ***REMOVED***, ***REMOVED*** skipNulls: true ***REMOVED***), 'a=b');
        st.end();
    ***REMOVED***);

    t.test('omits nested nulls when asked', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c', d: null ***REMOVED*** ***REMOVED***, ***REMOVED*** skipNulls: true ***REMOVED***), 'a%5Bb%5D=c');
        st.end();
    ***REMOVED***);

    t.test('omits array indices when asked', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c', 'd'] ***REMOVED***, ***REMOVED*** indices: false ***REMOVED***), 'a=b&a=c&a=d');
        st.end();
    ***REMOVED***);

    t.test('stringifies a nested array value', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***, ***REMOVED*** arrayFormat: 'indices' ***REMOVED***), 'a%5Bb%5D%5B0%5D=c&a%5Bb%5D%5B1%5D=d');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***, ***REMOVED*** arrayFormat: 'brackets' ***REMOVED***), 'a%5Bb%5D%5B%5D=c&a%5Bb%5D%5B%5D=d');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***, ***REMOVED*** arrayFormat: 'comma' ***REMOVED***), 'a%5Bb%5D=c%2Cd'); // a[b]=c,d
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***), 'a%5Bb%5D%5B0%5D=c&a%5Bb%5D%5B1%5D=d');
        st.end();
    ***REMOVED***);

    t.test('stringifies a nested array value with dots notation', function (st) ***REMOVED***
        st.equal(
            qs.stringify(
                ***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false, arrayFormat: 'indices' ***REMOVED***
            ),
            'a.b[0]=c&a.b[1]=d',
            'indices: stringifies with dots + indices'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false, arrayFormat: 'brackets' ***REMOVED***
            ),
            'a.b[]=c&a.b[]=d',
            'brackets: stringifies with dots + brackets'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false, arrayFormat: 'comma' ***REMOVED***
            ),
            'a.b=c,d',
            'comma: stringifies with dots + comma'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: ***REMOVED*** b: ['c', 'd'] ***REMOVED*** ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false ***REMOVED***
            ),
            'a.b[0]=c&a.b[1]=d',
            'default: stringifies with dots + indices'
        );
        st.end();
    ***REMOVED***);

    t.test('stringifies an object inside an array', function (st) ***REMOVED***
        st.equal(
            qs.stringify(***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***, ***REMOVED*** arrayFormat: 'indices' ***REMOVED***),
            'a%5B0%5D%5Bb%5D=c', // a[0][b]=c
            'indices => brackets'
        );
        st.equal(
            qs.stringify(***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***, ***REMOVED*** arrayFormat: 'brackets' ***REMOVED***),
            'a%5B%5D%5Bb%5D=c', // a[][b]=c
            'brackets => brackets'
        );
        st.equal(
            qs.stringify(***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***),
            'a%5B0%5D%5Bb%5D=c',
            'default => indices'
        );

        st.equal(
            qs.stringify(***REMOVED*** a: [***REMOVED*** b: ***REMOVED*** c: [1] ***REMOVED*** ***REMOVED***] ***REMOVED***, ***REMOVED*** arrayFormat: 'indices' ***REMOVED***),
            'a%5B0%5D%5Bb%5D%5Bc%5D%5B0%5D=1',
            'indices => indices'
        );

        st.equal(
            qs.stringify(***REMOVED*** a: [***REMOVED*** b: ***REMOVED*** c: [1] ***REMOVED*** ***REMOVED***] ***REMOVED***, ***REMOVED*** arrayFormat: 'brackets' ***REMOVED***),
            'a%5B%5D%5Bb%5D%5Bc%5D%5B%5D=1',
            'brackets => brackets'
        );

        st.equal(
            qs.stringify(***REMOVED*** a: [***REMOVED*** b: ***REMOVED*** c: [1] ***REMOVED*** ***REMOVED***] ***REMOVED***),
            'a%5B0%5D%5Bb%5D%5Bc%5D%5B0%5D=1',
            'default => indices'
        );

        st.end();
    ***REMOVED***);

    t.test('stringifies an array with mixed objects and primitives', function (st) ***REMOVED***
        st.equal(
            qs.stringify(***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, 2, 3] ***REMOVED***, ***REMOVED*** encode: false, arrayFormat: 'indices' ***REMOVED***),
            'a[0][b]=1&a[1]=2&a[2]=3',
            'indices => indices'
        );
        st.equal(
            qs.stringify(***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, 2, 3] ***REMOVED***, ***REMOVED*** encode: false, arrayFormat: 'brackets' ***REMOVED***),
            'a[][b]=1&a[]=2&a[]=3',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify(***REMOVED*** a: [***REMOVED*** b: 1 ***REMOVED***, 2, 3] ***REMOVED***, ***REMOVED*** encode: false ***REMOVED***),
            'a[0][b]=1&a[1]=2&a[2]=3',
            'default => indices'
        );

        st.end();
    ***REMOVED***);

    t.test('stringifies an object inside an array with dots notation', function (st) ***REMOVED***
        st.equal(
            qs.stringify(
                ***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false, arrayFormat: 'indices' ***REMOVED***
            ),
            'a[0].b=c',
            'indices => indices'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false, arrayFormat: 'brackets' ***REMOVED***
            ),
            'a[].b=c',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false ***REMOVED***
            ),
            'a[0].b=c',
            'default => indices'
        );

        st.equal(
            qs.stringify(
                ***REMOVED*** a: [***REMOVED*** b: ***REMOVED*** c: [1] ***REMOVED*** ***REMOVED***] ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false, arrayFormat: 'indices' ***REMOVED***
            ),
            'a[0].b.c[0]=1',
            'indices => indices'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: [***REMOVED*** b: ***REMOVED*** c: [1] ***REMOVED*** ***REMOVED***] ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false, arrayFormat: 'brackets' ***REMOVED***
            ),
            'a[].b.c[]=1',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: [***REMOVED*** b: ***REMOVED*** c: [1] ***REMOVED*** ***REMOVED***] ***REMOVED***,
                ***REMOVED*** allowDots: true, encode: false ***REMOVED***
            ),
            'a[0].b.c[0]=1',
            'default => indices'
        );

        st.end();
    ***REMOVED***);

    t.test('does not omit object keys when indices = false', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: [***REMOVED*** b: 'c' ***REMOVED***] ***REMOVED***, ***REMOVED*** indices: false ***REMOVED***), 'a%5Bb%5D=c');
        st.end();
    ***REMOVED***);

    t.test('uses indices notation for arrays when indices=true', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***, ***REMOVED*** indices: true ***REMOVED***), 'a%5B0%5D=b&a%5B1%5D=c');
        st.end();
    ***REMOVED***);

    t.test('uses indices notation for arrays when no arrayFormat is specified', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***), 'a%5B0%5D=b&a%5B1%5D=c');
        st.end();
    ***REMOVED***);

    t.test('uses indices notation for arrays when no arrayFormat=indices', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***, ***REMOVED*** arrayFormat: 'indices' ***REMOVED***), 'a%5B0%5D=b&a%5B1%5D=c');
        st.end();
    ***REMOVED***);

    t.test('uses repeat notation for arrays when no arrayFormat=repeat', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***, ***REMOVED*** arrayFormat: 'repeat' ***REMOVED***), 'a=b&a=c');
        st.end();
    ***REMOVED***);

    t.test('uses brackets notation for arrays when no arrayFormat=brackets', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ['b', 'c'] ***REMOVED***, ***REMOVED*** arrayFormat: 'brackets' ***REMOVED***), 'a%5B%5D=b&a%5B%5D=c');
        st.end();
    ***REMOVED***);

    t.test('stringifies a complicated object', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c', d: 'e' ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=c&a%5Bd%5D=e');
        st.end();
    ***REMOVED***);

    t.test('stringifies an empty value', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: '' ***REMOVED***), 'a=');
        st.equal(qs.stringify(***REMOVED*** a: null ***REMOVED***, ***REMOVED*** strictNullHandling: true ***REMOVED***), 'a');

        st.equal(qs.stringify(***REMOVED*** a: '', b: '' ***REMOVED***), 'a=&b=');
        st.equal(qs.stringify(***REMOVED*** a: null, b: '' ***REMOVED***, ***REMOVED*** strictNullHandling: true ***REMOVED***), 'a&b=');

        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: '' ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: null ***REMOVED*** ***REMOVED***, ***REMOVED*** strictNullHandling: true ***REMOVED***), 'a%5Bb%5D');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: null ***REMOVED*** ***REMOVED***, ***REMOVED*** strictNullHandling: false ***REMOVED***), 'a%5Bb%5D=');

        st.end();
    ***REMOVED***);

    t.test('stringifies a null object', ***REMOVED*** skip: !Object.create ***REMOVED***, function (st) ***REMOVED***
        var obj = Object.create(null);
        obj.a = 'b';
        st.equal(qs.stringify(obj), 'a=b');
        st.end();
    ***REMOVED***);

    t.test('returns an empty string for invalid input', function (st) ***REMOVED***
        st.equal(qs.stringify(undefined), '');
        st.equal(qs.stringify(false), '');
        st.equal(qs.stringify(null), '');
        st.equal(qs.stringify(''), '');
        st.end();
    ***REMOVED***);

    t.test('stringifies an object with a null object as a child', ***REMOVED*** skip: !Object.create ***REMOVED***, function (st) ***REMOVED***
        var obj = ***REMOVED*** a: Object.create(null) ***REMOVED***;

        obj.a.b = 'c';
        st.equal(qs.stringify(obj), 'a%5Bb%5D=c');
        st.end();
    ***REMOVED***);

    t.test('drops keys with a value of undefined', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: undefined ***REMOVED***), '');

        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: undefined, c: null ***REMOVED*** ***REMOVED***, ***REMOVED*** strictNullHandling: true ***REMOVED***), 'a%5Bc%5D');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: undefined, c: null ***REMOVED*** ***REMOVED***, ***REMOVED*** strictNullHandling: false ***REMOVED***), 'a%5Bc%5D=');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: undefined, c: '' ***REMOVED*** ***REMOVED***), 'a%5Bc%5D=');
        st.end();
    ***REMOVED***);

    t.test('url encodes values', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b c' ***REMOVED***), 'a=b%20c');
        st.end();
    ***REMOVED***);

    t.test('stringifies a date', function (st) ***REMOVED***
        var now = new Date();
        var str = 'a=' + encodeURIComponent(now.toISOString());
        st.equal(qs.stringify(***REMOVED*** a: now ***REMOVED***), str);
        st.end();
    ***REMOVED***);

    t.test('stringifies the weird object from qs', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** 'my weird field': '~q1!2"\'w$5&7/z8)?' ***REMOVED***), 'my%20weird%20field=~q1%212%22%27w%245%267%2Fz8%29%3F');
        st.end();
    ***REMOVED***);

    t.test('skips properties that are part of the object prototype', function (st) ***REMOVED***
        Object.prototype.crash = 'test';
        st.equal(qs.stringify(***REMOVED*** a: 'b' ***REMOVED***), 'a=b');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=c');
        delete Object.prototype.crash;
        st.end();
    ***REMOVED***);

    t.test('stringifies boolean values', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: true ***REMOVED***), 'a=true');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: true ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=true');
        st.equal(qs.stringify(***REMOVED*** b: false ***REMOVED***), 'b=false');
        st.equal(qs.stringify(***REMOVED*** b: ***REMOVED*** c: false ***REMOVED*** ***REMOVED***), 'b%5Bc%5D=false');
        st.end();
    ***REMOVED***);

    t.test('stringifies buffer values', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: SaferBuffer.from('test') ***REMOVED***), 'a=test');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: SaferBuffer.from('test') ***REMOVED*** ***REMOVED***), 'a%5Bb%5D=test');
        st.end();
    ***REMOVED***);

    t.test('stringifies an object using an alternative delimiter', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b', c: 'd' ***REMOVED***, ***REMOVED*** delimiter: ';' ***REMOVED***), 'a=b;c=d');
        st.end();
    ***REMOVED***);

    t.test('doesn\'t blow up when Buffer global is missing', function (st) ***REMOVED***
        var tempBuffer = global.Buffer;
        delete global.Buffer;
        var result = qs.stringify(***REMOVED*** a: 'b', c: 'd' ***REMOVED***);
        global.Buffer = tempBuffer;
        st.equal(result, 'a=b&c=d');
        st.end();
    ***REMOVED***);

    t.test('selects properties when filter=array', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b' ***REMOVED***, ***REMOVED*** filter: ['a'] ***REMOVED***), 'a=b');
        st.equal(qs.stringify(***REMOVED*** a: 1 ***REMOVED***, ***REMOVED*** filter: [] ***REMOVED***), '');

        st.equal(
            qs.stringify(
                ***REMOVED*** a: ***REMOVED*** b: [1, 2, 3, 4], c: 'd' ***REMOVED***, c: 'f' ***REMOVED***,
                ***REMOVED*** filter: ['a', 'b', 0, 2], arrayFormat: 'indices' ***REMOVED***
            ),
            'a%5Bb%5D%5B0%5D=1&a%5Bb%5D%5B2%5D=3',
            'indices => indices'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: ***REMOVED*** b: [1, 2, 3, 4], c: 'd' ***REMOVED***, c: 'f' ***REMOVED***,
                ***REMOVED*** filter: ['a', 'b', 0, 2], arrayFormat: 'brackets' ***REMOVED***
            ),
            'a%5Bb%5D%5B%5D=1&a%5Bb%5D%5B%5D=3',
            'brackets => brackets'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: ***REMOVED*** b: [1, 2, 3, 4], c: 'd' ***REMOVED***, c: 'f' ***REMOVED***,
                ***REMOVED*** filter: ['a', 'b', 0, 2] ***REMOVED***
            ),
            'a%5Bb%5D%5B0%5D=1&a%5Bb%5D%5B2%5D=3',
            'default => indices'
        );

        st.end();
    ***REMOVED***);

    t.test('supports custom representations when filter=function', function (st) ***REMOVED***
        var calls = 0;
        var obj = ***REMOVED*** a: 'b', c: 'd', e: ***REMOVED*** f: new Date(1257894000000) ***REMOVED*** ***REMOVED***;
        var filterFunc = function (prefix, value) ***REMOVED***
            calls += 1;
            if (calls === 1) ***REMOVED***
                st.equal(prefix, '', 'prefix is empty');
                st.equal(value, obj);
            ***REMOVED*** else if (prefix === 'c') ***REMOVED***
                return void 0;
            ***REMOVED*** else if (value instanceof Date) ***REMOVED***
                st.equal(prefix, 'e[f]');
                return value.getTime();
            ***REMOVED***
            return value;
        ***REMOVED***;

        st.equal(qs.stringify(obj, ***REMOVED*** filter: filterFunc ***REMOVED***), 'a=b&e%5Bf%5D=1257894000000');
        st.equal(calls, 5);
        st.end();
    ***REMOVED***);

    t.test('can disable uri encoding', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b' ***REMOVED***, ***REMOVED*** encode: false ***REMOVED***), 'a=b');
        st.equal(qs.stringify(***REMOVED*** a: ***REMOVED*** b: 'c' ***REMOVED*** ***REMOVED***, ***REMOVED*** encode: false ***REMOVED***), 'a[b]=c');
        st.equal(qs.stringify(***REMOVED*** a: 'b', c: null ***REMOVED***, ***REMOVED*** strictNullHandling: true, encode: false ***REMOVED***), 'a=b&c');
        st.end();
    ***REMOVED***);

    t.test('can sort the keys', function (st) ***REMOVED***
        var sort = function (a, b) ***REMOVED***
            return a.localeCompare(b);
        ***REMOVED***;
        st.equal(qs.stringify(***REMOVED*** a: 'c', z: 'y', b: 'f' ***REMOVED***, ***REMOVED*** sort: sort ***REMOVED***), 'a=c&b=f&z=y');
        st.equal(qs.stringify(***REMOVED*** a: 'c', z: ***REMOVED*** j: 'a', i: 'b' ***REMOVED***, b: 'f' ***REMOVED***, ***REMOVED*** sort: sort ***REMOVED***), 'a=c&b=f&z%5Bi%5D=b&z%5Bj%5D=a');
        st.end();
    ***REMOVED***);

    t.test('can sort the keys at depth 3 or more too', function (st) ***REMOVED***
        var sort = function (a, b) ***REMOVED***
            return a.localeCompare(b);
        ***REMOVED***;
        st.equal(
            qs.stringify(
                ***REMOVED*** a: 'a', z: ***REMOVED*** zj: ***REMOVED*** zjb: 'zjb', zja: 'zja' ***REMOVED***, zi: ***REMOVED*** zib: 'zib', zia: 'zia' ***REMOVED*** ***REMOVED***, b: 'b' ***REMOVED***,
                ***REMOVED*** sort: sort, encode: false ***REMOVED***
            ),
            'a=a&b=b&z[zi][zia]=zia&z[zi][zib]=zib&z[zj][zja]=zja&z[zj][zjb]=zjb'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: 'a', z: ***REMOVED*** zj: ***REMOVED*** zjb: 'zjb', zja: 'zja' ***REMOVED***, zi: ***REMOVED*** zib: 'zib', zia: 'zia' ***REMOVED*** ***REMOVED***, b: 'b' ***REMOVED***,
                ***REMOVED*** sort: null, encode: false ***REMOVED***
            ),
            'a=a&z[zj][zjb]=zjb&z[zj][zja]=zja&z[zi][zib]=zib&z[zi][zia]=zia&b=b'
        );
        st.end();
    ***REMOVED***);

    t.test('can stringify with custom encoding', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** çœŒ: 'å¤§é˜ªåºœ', '': '' ***REMOVED***, ***REMOVED***
            encoder: function (str) ***REMOVED***
                if (str.length === 0) ***REMOVED***
                    return '';
                ***REMOVED***
                var buf = iconv.encode(str, 'shiftjis');
                var result = [];
                for (var i = 0; i < buf.length; ++i) ***REMOVED***
                    result.push(buf.readUInt8(i).toString(16));
                ***REMOVED***
                return '%' + result.join('%');
            ***REMOVED***
        ***REMOVED***), '%8c%a7=%91%e5%8d%e3%95%7b&=');
        st.end();
    ***REMOVED***);

    t.test('receives the default encoder as a second argument', function (st) ***REMOVED***
        st.plan(2);
        qs.stringify(***REMOVED*** a: 1 ***REMOVED***, ***REMOVED***
            encoder: function (str, defaultEncoder) ***REMOVED***
                st.equal(defaultEncoder, utils.encode);
            ***REMOVED***
        ***REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('throws error with wrong encoder', function (st) ***REMOVED***
        st['throws'](function () ***REMOVED***
            qs.stringify(***REMOVED******REMOVED***, ***REMOVED*** encoder: 'string' ***REMOVED***);
    ***REMOVED*** new TypeError('Encoder has to be a function.'));
        st.end();
    ***REMOVED***);

    t.test('can use custom encoder for a buffer object', ***REMOVED*** skip: typeof Buffer === 'undefined' ***REMOVED***, function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: SaferBuffer.from([1]) ***REMOVED***, ***REMOVED***
            encoder: function (buffer) ***REMOVED***
                if (typeof buffer === 'string') ***REMOVED***
                    return buffer;
                ***REMOVED***
                return String.fromCharCode(buffer.readUInt8(0) + 97);
            ***REMOVED***
        ***REMOVED***), 'a=b');

        st.equal(qs.stringify(***REMOVED*** a: SaferBuffer.from('a b') ***REMOVED***, ***REMOVED***
            encoder: function (buffer) ***REMOVED***
                return buffer;
            ***REMOVED***
        ***REMOVED***), 'a=a b');
        st.end();
    ***REMOVED***);

    t.test('serializeDate option', function (st) ***REMOVED***
        var date = new Date();
        st.equal(
            qs.stringify(***REMOVED*** a: date ***REMOVED***),
            'a=' + date.toISOString().replace(/:/g, '%3A'),
            'default is toISOString'
        );

        var mutatedDate = new Date();
        mutatedDate.toISOString = function () ***REMOVED***
            throw new SyntaxError();
        ***REMOVED***;
        st['throws'](function () ***REMOVED***
            mutatedDate.toISOString();
    ***REMOVED*** SyntaxError);
        st.equal(
            qs.stringify(***REMOVED*** a: mutatedDate ***REMOVED***),
            'a=' + Date.prototype.toISOString.call(mutatedDate).replace(/:/g, '%3A'),
            'toISOString works even when method is not locally present'
        );

        var specificDate = new Date(6);
        st.equal(
            qs.stringify(
                ***REMOVED*** a: specificDate ***REMOVED***,
                ***REMOVED*** serializeDate: function (d) ***REMOVED*** return d.getTime() * 7; ***REMOVED*** ***REMOVED***
            ),
            'a=42',
            'custom serializeDate function called'
        );

        st.end();
    ***REMOVED***);

    t.test('RFC 1738 spaces serialization', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b c' ***REMOVED***, ***REMOVED*** format: qs.formats.RFC1738 ***REMOVED***), 'a=b+c');
        st.equal(qs.stringify(***REMOVED*** 'a b': 'c d' ***REMOVED***, ***REMOVED*** format: qs.formats.RFC1738 ***REMOVED***), 'a+b=c+d');
        st.equal(qs.stringify(***REMOVED*** 'a b': SaferBuffer.from('a b') ***REMOVED***, ***REMOVED*** format: qs.formats.RFC1738 ***REMOVED***), 'a+b=a+b');
        st.end();
    ***REMOVED***);

    t.test('RFC 3986 spaces serialization', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b c' ***REMOVED***, ***REMOVED*** format: qs.formats.RFC3986 ***REMOVED***), 'a=b%20c');
        st.equal(qs.stringify(***REMOVED*** 'a b': 'c d' ***REMOVED***, ***REMOVED*** format: qs.formats.RFC3986 ***REMOVED***), 'a%20b=c%20d');
        st.equal(qs.stringify(***REMOVED*** 'a b': SaferBuffer.from('a b') ***REMOVED***, ***REMOVED*** format: qs.formats.RFC3986 ***REMOVED***), 'a%20b=a%20b');
        st.end();
    ***REMOVED***);

    t.test('Backward compatibility to RFC 3986', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'b c' ***REMOVED***), 'a=b%20c');
        st.equal(qs.stringify(***REMOVED*** 'a b': SaferBuffer.from('a b') ***REMOVED***), 'a%20b=a%20b');
        st.end();
    ***REMOVED***);

    t.test('Edge cases and unknown formats', function (st) ***REMOVED***
        ['UFO1234', false, 1234, null, ***REMOVED******REMOVED***, []].forEach(
            function (format) ***REMOVED***
                st['throws'](
                    function () ***REMOVED***
                        qs.stringify(***REMOVED*** a: 'b c' ***REMOVED***, ***REMOVED*** format: format ***REMOVED***);
                ***REMOVED***
                    new TypeError('Unknown format option provided.')
                );
            ***REMOVED***
        );
        st.end();
    ***REMOVED***);

    t.test('encodeValuesOnly', function (st) ***REMOVED***
        st.equal(
            qs.stringify(
                ***REMOVED*** a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] ***REMOVED***,
                ***REMOVED*** encodeValuesOnly: true ***REMOVED***
            ),
            'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h'
        );
        st.equal(
            qs.stringify(
                ***REMOVED*** a: 'b', c: ['d', 'e'], f: [['g'], ['h']] ***REMOVED***
            ),
            'a=b&c%5B0%5D=d&c%5B1%5D=e&f%5B0%5D%5B0%5D=g&f%5B1%5D%5B0%5D=h'
        );
        st.end();
    ***REMOVED***);

    t.test('encodeValuesOnly - strictNullHandling', function (st) ***REMOVED***
        st.equal(
            qs.stringify(
                ***REMOVED*** a: ***REMOVED*** b: null ***REMOVED*** ***REMOVED***,
                ***REMOVED*** encodeValuesOnly: true, strictNullHandling: true ***REMOVED***
            ),
            'a[b]'
        );
        st.end();
    ***REMOVED***);

    t.test('throws if an invalid charset is specified', function (st) ***REMOVED***
        st['throws'](function () ***REMOVED***
            qs.stringify(***REMOVED*** a: 'b' ***REMOVED***, ***REMOVED*** charset: 'foobar' ***REMOVED***);
    ***REMOVED*** new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined'));
        st.end();
    ***REMOVED***);

    t.test('respects a charset of iso-8859-1', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** Ã¦: 'Ã¦' ***REMOVED***, ***REMOVED*** charset: 'iso-8859-1' ***REMOVED***), '%E6=%E6');
        st.end();
    ***REMOVED***);

    t.test('encodes unrepresentable chars as numeric entities in iso-8859-1 mode', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'â˜º' ***REMOVED***, ***REMOVED*** charset: 'iso-8859-1' ***REMOVED***), 'a=%26%239786%3B');
        st.end();
    ***REMOVED***);

    t.test('respects an explicit charset of utf-8 (the default)', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'Ã¦' ***REMOVED***, ***REMOVED*** charset: 'utf-8' ***REMOVED***), 'a=%C3%A6');
        st.end();
    ***REMOVED***);

    t.test('adds the right sentinel when instructed to and the charset is utf-8', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'Ã¦' ***REMOVED***, ***REMOVED*** charsetSentinel: true, charset: 'utf-8' ***REMOVED***), 'utf8=%E2%9C%93&a=%C3%A6');
        st.end();
    ***REMOVED***);

    t.test('adds the right sentinel when instructed to and the charset is iso-8859-1', function (st) ***REMOVED***
        st.equal(qs.stringify(***REMOVED*** a: 'Ã¦' ***REMOVED***, ***REMOVED*** charsetSentinel: true, charset: 'iso-8859-1' ***REMOVED***), 'utf8=%26%2310003%3B&a=%E6');
        st.end();
    ***REMOVED***);

    t.test('does not mutate the options argument', function (st) ***REMOVED***
        var options = ***REMOVED******REMOVED***;
        qs.stringify(***REMOVED******REMOVED***, options);
        st.deepEqual(options, ***REMOVED******REMOVED***);
        st.end();
    ***REMOVED***);

    t.test('strictNullHandling works with custom filter', function (st) ***REMOVED***
        var filter = function (prefix, value) ***REMOVED***
            return value;
        ***REMOVED***;

        var options = ***REMOVED*** strictNullHandling: true, filter: filter ***REMOVED***;
        st.equal(qs.stringify(***REMOVED*** key: null ***REMOVED***, options), 'key');
        st.end();
    ***REMOVED***);

    t.test('strictNullHandling works with null serializeDate', function (st) ***REMOVED***
        var serializeDate = function () ***REMOVED***
            return null;
        ***REMOVED***;
        var options = ***REMOVED*** strictNullHandling: true, serializeDate: serializeDate ***REMOVED***;
        var date = new Date();
        st.equal(qs.stringify(***REMOVED*** key: date ***REMOVED***, options), 'key');
        st.end();
    ***REMOVED***);

    t.test('allows for encoding keys and values differently', function (st) ***REMOVED***
        var encoder = function (str, defaultEncoder, charset, type) ***REMOVED***
            if (type === 'key') ***REMOVED***
                return defaultEncoder(str, defaultEncoder, charset, type).toLowerCase();
            ***REMOVED***
            if (type === 'value') ***REMOVED***
                return defaultEncoder(str, defaultEncoder, charset, type).toUpperCase();
            ***REMOVED***
            throw 'this should never happen! type: ' + type;
        ***REMOVED***;

        st.deepEqual(qs.stringify(***REMOVED*** KeY: 'vAlUe' ***REMOVED***, ***REMOVED*** encoder: encoder ***REMOVED***), 'key=VALUE');
        st.end();
    ***REMOVED***);

    t.end();
***REMOVED***);
