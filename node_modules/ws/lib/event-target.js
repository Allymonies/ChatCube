'use strict';

const ***REMOVED*** kForOnEventAttribute, kListener ***REMOVED*** = require('./constants');

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event ***REMOVED***
  /**
   * Create a new `Event`.
   *
   * @param ***REMOVED***String***REMOVED*** type The name of the event
   * @throws ***REMOVED***TypeError***REMOVED*** If the `type` argument is not specified
   */
  constructor(type) ***REMOVED***
    this[kTarget] = null;
    this[kType] = type;
  ***REMOVED***

  /**
   * @type ***REMOVED*******REMOVED***
   */
  get target() ***REMOVED***
    return this[kTarget];
  ***REMOVED***

  /**
   * @type ***REMOVED***String***REMOVED***
   */
  get type() ***REMOVED***
    return this[kType];
  ***REMOVED***
***REMOVED***

Object.defineProperty(Event.prototype, 'target', ***REMOVED*** enumerable: true ***REMOVED***);
Object.defineProperty(Event.prototype, 'type', ***REMOVED*** enumerable: true ***REMOVED***);

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event ***REMOVED***
  /**
   * Create a new `CloseEvent`.
   *
   * @param ***REMOVED***String***REMOVED*** type The name of the event
   * @param ***REMOVED***Object***REMOVED*** [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param ***REMOVED***Number***REMOVED*** [options.code=0] The status code explaining why the
   *     connection was closed
   * @param ***REMOVED***String***REMOVED*** [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param ***REMOVED***Boolean***REMOVED*** [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = ***REMOVED******REMOVED***) ***REMOVED***
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  ***REMOVED***

  /**
   * @type ***REMOVED***Number***REMOVED***
   */
  get code() ***REMOVED***
    return this[kCode];
  ***REMOVED***

  /**
   * @type ***REMOVED***String***REMOVED***
   */
  get reason() ***REMOVED***
    return this[kReason];
  ***REMOVED***

  /**
   * @type ***REMOVED***Boolean***REMOVED***
   */
  get wasClean() ***REMOVED***
    return this[kWasClean];
  ***REMOVED***
***REMOVED***

Object.defineProperty(CloseEvent.prototype, 'code', ***REMOVED*** enumerable: true ***REMOVED***);
Object.defineProperty(CloseEvent.prototype, 'reason', ***REMOVED*** enumerable: true ***REMOVED***);
Object.defineProperty(CloseEvent.prototype, 'wasClean', ***REMOVED*** enumerable: true ***REMOVED***);

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event ***REMOVED***
  /**
   * Create a new `ErrorEvent`.
   *
   * @param ***REMOVED***String***REMOVED*** type The name of the event
   * @param ***REMOVED***Object***REMOVED*** [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param ***REMOVED*******REMOVED*** [options.error=null] The error that generated this event
   * @param ***REMOVED***String***REMOVED*** [options.message=''] The error message
   */
  constructor(type, options = ***REMOVED******REMOVED***) ***REMOVED***
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  ***REMOVED***

  /**
   * @type ***REMOVED*******REMOVED***
   */
  get error() ***REMOVED***
    return this[kError];
  ***REMOVED***

  /**
   * @type ***REMOVED***String***REMOVED***
   */
  get message() ***REMOVED***
    return this[kMessage];
  ***REMOVED***
***REMOVED***

Object.defineProperty(ErrorEvent.prototype, 'error', ***REMOVED*** enumerable: true ***REMOVED***);
Object.defineProperty(ErrorEvent.prototype, 'message', ***REMOVED*** enumerable: true ***REMOVED***);

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event ***REMOVED***
  /**
   * Create a new `MessageEvent`.
   *
   * @param ***REMOVED***String***REMOVED*** type The name of the event
   * @param ***REMOVED***Object***REMOVED*** [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param ***REMOVED*******REMOVED*** [options.data=null] The message content
   */
  constructor(type, options = ***REMOVED******REMOVED***) ***REMOVED***
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  ***REMOVED***

  /**
   * @type ***REMOVED*******REMOVED***
   */
  get data() ***REMOVED***
    return this[kData];
  ***REMOVED***
***REMOVED***

Object.defineProperty(MessageEvent.prototype, 'data', ***REMOVED*** enumerable: true ***REMOVED***);

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = ***REMOVED***
  /**
   * Register an event listener.
   *
   * @param ***REMOVED***String***REMOVED*** type A string representing the event type to listen for
   * @param ***REMOVED***Function***REMOVED*** listener The listener to add
   * @param ***REMOVED***Object***REMOVED*** [options] An options object specifies characteristics about
   *     the event listener
   * @param ***REMOVED***Boolean***REMOVED*** [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options = ***REMOVED******REMOVED***) ***REMOVED***
    let wrapper;

    if (type === 'message') ***REMOVED***
      wrapper = function onMessage(data, isBinary) ***REMOVED***
        const event = new MessageEvent('message', ***REMOVED***
          data: isBinary ? data : data.toString()
        ***REMOVED***);

        event[kTarget] = this;
        listener.call(this, event);
      ***REMOVED***;
    ***REMOVED*** else if (type === 'close') ***REMOVED***
      wrapper = function onClose(code, message) ***REMOVED***
        const event = new CloseEvent('close', ***REMOVED***
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        ***REMOVED***);

        event[kTarget] = this;
        listener.call(this, event);
      ***REMOVED***;
    ***REMOVED*** else if (type === 'error') ***REMOVED***
      wrapper = function onError(error) ***REMOVED***
        const event = new ErrorEvent('error', ***REMOVED***
          error,
          message: error.message
        ***REMOVED***);

        event[kTarget] = this;
        listener.call(this, event);
      ***REMOVED***;
    ***REMOVED*** else if (type === 'open') ***REMOVED***
      wrapper = function onOpen() ***REMOVED***
        const event = new Event('open');

        event[kTarget] = this;
        listener.call(this, event);
      ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
      return;
    ***REMOVED***

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = listener;

    if (options.once) ***REMOVED***
      this.once(type, wrapper);
    ***REMOVED*** else ***REMOVED***
      this.on(type, wrapper);
    ***REMOVED***
  ***REMOVED***,

  /**
   * Remove an event listener.
   *
   * @param ***REMOVED***String***REMOVED*** type A string representing the event type to remove
   * @param ***REMOVED***Function***REMOVED*** handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) ***REMOVED***
    for (const listener of this.listeners(type)) ***REMOVED***
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) ***REMOVED***
        this.removeListener(type, listener);
        break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

module.exports = ***REMOVED***
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
***REMOVED***;
