/* eslint no-unused-vars: ["error", ***REMOVED*** "varsIgnorePattern": "^net|tls|https$" ***REMOVED***] */

'use strict';

const EventEmitter = require('events');
const http = require('http');
const https = require('https');
const net = require('net');
const tls = require('tls');
const ***REMOVED*** createHash ***REMOVED*** = require('crypto');

const extension = require('./extension');
const PerMessageDeflate = require('./permessage-deflate');
const subprotocol = require('./subprotocol');
const WebSocket = require('./websocket');
const ***REMOVED*** GUID, kWebSocket ***REMOVED*** = require('./constants');

const keyRegex = /^[+/0-9A-Za-z]***REMOVED***22***REMOVED***==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter ***REMOVED***
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param ***REMOVED***Object***REMOVED*** options Configuration options
   * @param ***REMOVED***Number***REMOVED*** [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param ***REMOVED***Boolean***REMOVED*** [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param ***REMOVED***Function***REMOVED*** [options.handleProtocols] A hook to handle protocols
   * @param ***REMOVED***String***REMOVED*** [options.host] The hostname where to bind the server
   * @param ***REMOVED***Number***REMOVED*** [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param ***REMOVED***Boolean***REMOVED*** [options.noServer=false] Enable no server mode
   * @param ***REMOVED***String***REMOVED*** [options.path] Accept only connections matching this path
   * @param ***REMOVED***(Boolean|Object)***REMOVED*** [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param ***REMOVED***Number***REMOVED*** [options.port] The port where to bind the server
   * @param ***REMOVED***(http.Server|https.Server)***REMOVED*** [options.server] A pre-created HTTP/S
   *     server to use
   * @param ***REMOVED***Boolean***REMOVED*** [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param ***REMOVED***Function***REMOVED*** [options.verifyClient] A hook to reject connections
   * @param ***REMOVED***Function***REMOVED*** [callback] A listener for the `listening` event
   */
  constructor(options, callback) ***REMOVED***
    super();

    options = ***REMOVED***
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    ***REMOVED***;

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) ***REMOVED***
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    ***REMOVED***

    if (options.port != null) ***REMOVED***
      this._server = http.createServer((req, res) => ***REMOVED***
        const body = http.STATUS_CODES[426];

        res.writeHead(426, ***REMOVED***
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        ***REMOVED***);
        res.end(body);
      ***REMOVED***);
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    ***REMOVED*** else if (options.server) ***REMOVED***
      this._server = options.server;
    ***REMOVED***

    if (this._server) ***REMOVED***
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, ***REMOVED***
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => ***REMOVED***
          this.handleUpgrade(req, socket, head, emitConnection);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    if (options.perMessageDeflate === true) options.perMessageDeflate = ***REMOVED******REMOVED***;
    if (options.clientTracking) ***REMOVED***
      this.clients = new Set();
      this._shouldEmitClose = false;
    ***REMOVED***

    this.options = options;
    this._state = RUNNING;
  ***REMOVED***

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return ***REMOVED***(Object|String|null)***REMOVED*** The address of the server
   * @public
   */
  address() ***REMOVED***
    if (this.options.noServer) ***REMOVED***
      throw new Error('The server is operating in "noServer" mode');
    ***REMOVED***

    if (!this._server) return null;
    return this._server.address();
  ***REMOVED***

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param ***REMOVED***Function***REMOVED*** [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) ***REMOVED***
    if (this._state === CLOSED) ***REMOVED***
      if (cb) ***REMOVED***
        this.once('close', () => ***REMOVED***
          cb(new Error('The server is not running'));
        ***REMOVED***);
      ***REMOVED***

      process.nextTick(emitClose, this);
      return;
    ***REMOVED***

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) ***REMOVED***
      if (this._server) ***REMOVED***
        this._removeListeners();
        this._removeListeners = this._server = null;
      ***REMOVED***

      if (this.clients) ***REMOVED***
        if (!this.clients.size) ***REMOVED***
          process.nextTick(emitClose, this);
        ***REMOVED*** else ***REMOVED***
          this._shouldEmitClose = true;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        process.nextTick(emitClose, this);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => ***REMOVED***
        emitClose(this);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param ***REMOVED***http.IncomingMessage***REMOVED*** req Request object to inspect
   * @return ***REMOVED***Boolean***REMOVED*** `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) ***REMOVED***
    if (this.options.path) ***REMOVED***
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    ***REMOVED***

    return true;
  ***REMOVED***

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param ***REMOVED***http.IncomingMessage***REMOVED*** req The request object
   * @param ***REMOVED***(net.Socket|tls.Socket)***REMOVED*** socket The network socket between the
   *     server and client
   * @param ***REMOVED***Buffer***REMOVED*** head The first packet of the upgraded stream
   * @param ***REMOVED***Function***REMOVED*** cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) ***REMOVED***
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key']
        : false;
    const version = +req.headers['sec-websocket-version'];

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) ***REMOVED***
      return abortHandshake(socket, 400);
    ***REMOVED***

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) ***REMOVED***
      try ***REMOVED***
        protocols = subprotocol.parse(secWebSocketProtocol);
      ***REMOVED*** catch (err) ***REMOVED***
        return abortHandshake(socket, 400);
      ***REMOVED***
    ***REMOVED***

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = ***REMOVED******REMOVED***;

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) ***REMOVED***
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try ***REMOVED***
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) ***REMOVED***
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        ***REMOVED***
      ***REMOVED*** catch (err) ***REMOVED***
        return abortHandshake(socket, 400);
      ***REMOVED***
    ***REMOVED***

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) ***REMOVED***
      const info = ***REMOVED***
        origin:
          req.headers[`$***REMOVED***version === 8 ? 'sec-websocket-origin' : 'origin'***REMOVED***`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      ***REMOVED***;

      if (this.options.verifyClient.length === 2) ***REMOVED***
        this.options.verifyClient(info, (verified, code, message, headers) => ***REMOVED***
          if (!verified) ***REMOVED***
            return abortHandshake(socket, code || 401, message, headers);
          ***REMOVED***

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        ***REMOVED***);
        return;
      ***REMOVED***

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    ***REMOVED***

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  ***REMOVED***

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param ***REMOVED***Object***REMOVED*** extensions The accepted extensions
   * @param ***REMOVED***String***REMOVED*** key The value of the `Sec-WebSocket-Key` header
   * @param ***REMOVED***Set***REMOVED*** protocols The subprotocols
   * @param ***REMOVED***http.IncomingMessage***REMOVED*** req The request object
   * @param ***REMOVED***(net.Socket|tls.Socket)***REMOVED*** socket The network socket between the
   *     server and client
   * @param ***REMOVED***Buffer***REMOVED*** head The first packet of the upgraded stream
   * @param ***REMOVED***Function***REMOVED*** cb Callback
   * @throws ***REMOVED***Error***REMOVED*** If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) ***REMOVED***
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) ***REMOVED***
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    ***REMOVED***

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: $***REMOVED***digest***REMOVED***`
    ];

    const ws = new WebSocket(null);

    if (protocols.size) ***REMOVED***
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) ***REMOVED***
        headers.push(`Sec-WebSocket-Protocol: $***REMOVED***protocol***REMOVED***`);
        ws._protocol = protocol;
      ***REMOVED***
    ***REMOVED***

    if (extensions[PerMessageDeflate.extensionName]) ***REMOVED***
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format(***REMOVED***
        [PerMessageDeflate.extensionName]: [params]
      ***REMOVED***);
      headers.push(`Sec-WebSocket-Extensions: $***REMOVED***value***REMOVED***`);
      ws._extensions = extensions;
    ***REMOVED***

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, ***REMOVED***
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    ***REMOVED***);

    if (this.clients) ***REMOVED***
      this.clients.add(ws);
      ws.on('close', () => ***REMOVED***
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) ***REMOVED***
          process.nextTick(emitClose, this);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    cb(ws, req);
  ***REMOVED***
***REMOVED***

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param ***REMOVED***EventEmitter***REMOVED*** server The event emitter
 * @param ***REMOVED***Object.<String, Function>***REMOVED*** map The listeners to add
 * @return ***REMOVED***Function***REMOVED*** A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) ***REMOVED***
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() ***REMOVED***
    for (const event of Object.keys(map)) ***REMOVED***
      server.removeListener(event, map[event]);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param ***REMOVED***EventEmitter***REMOVED*** server The event emitter
 * @private
 */
function emitClose(server) ***REMOVED***
  server._state = CLOSED;
  server.emit('close');
***REMOVED***

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() ***REMOVED***
  this.destroy();
***REMOVED***

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param ***REMOVED***(net.Socket|tls.Socket)***REMOVED*** socket The socket of the upgrade request
 * @param ***REMOVED***Number***REMOVED*** code The HTTP response status code
 * @param ***REMOVED***String***REMOVED*** [message] The HTTP response body
 * @param ***REMOVED***Object***REMOVED*** [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) ***REMOVED***
  if (socket.writable) ***REMOVED***
    message = message || http.STATUS_CODES[code];
    headers = ***REMOVED***
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    ***REMOVED***;

    socket.write(
      `HTTP/1.1 $***REMOVED***code***REMOVED*** $***REMOVED***http.STATUS_CODES[code]***REMOVED***\r\n` +
        Object.keys(headers)
          .map((h) => `$***REMOVED***h***REMOVED***: $***REMOVED***headers[h]***REMOVED***`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  ***REMOVED***

  socket.removeListener('error', socketOnError);
  socket.destroy();
***REMOVED***
