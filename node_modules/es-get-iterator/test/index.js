'use strict';

var test = require('tape');
var Test = require('tape/lib/test');
var inspect = require('object-inspect');
// eslint-disable-next-line global-require
var hasSymbols = require('has-symbols')() || require('has-symbols/shams')();
var hasBigInts = require('has-bigints')();
var forEach = require('for-each');

var getIterator = process.env.TEST_VARIANT === 'node' ? require('../node') : require('../');

Test.prototype.iterate = function (value, expected, message) ***REMOVED***
	var i = 0;
	this.test(message, function (t) ***REMOVED***
		var iterator = getIterator(value);
		if (!iterator) ***REMOVED***
			t.fail(inspect(value) + ' is not iterable');
			return t.end();
		***REMOVED***
		if (typeof iterator.next !== 'function') ***REMOVED***
			t.fail('iterator does not have a next function, got ' + inspect(iterator));
			return t.end();
		***REMOVED***
		var result;
		while ((result = iterator.next()) && !result.done) ***REMOVED***
			t.deepEqual(result.value, expected[i], 'index ' + i + ': expected ' + inspect(expected[i]) + ', got ' + inspect(result.value));
			i += 1;
		***REMOVED***
		t.equal(i, expected.length, 'expected ' + expected.length + ' values, got ' + i + ' values');

		t.end();
	***REMOVED***);
***REMOVED***;

Test.prototype.noIterate = function (value) ***REMOVED***
	this.equal(getIterator(value), undefined, inspect(value) + ' is not iterable');
***REMOVED***;

Test.prototype.fakeIterator = function (value) ***REMOVED***
	this.test(inspect(value) + ' with a fake iterator', ***REMOVED*** skip: !hasSymbols ***REMOVED***, function (t) ***REMOVED***
		var fakeValues = ['fake', 'iterator', 'scary'];
		var o = Object(value);
		o[Symbol.iterator] = function () ***REMOVED***
			return getIterator(fakeValues);
		***REMOVED***;
		t.iterate(o, fakeValues, inspect(o) + ' with an overwritten iterator method, yields those values instead');
		t.end();
	***REMOVED***);
***REMOVED***;

var getArguments = function () ***REMOVED*** return arguments; ***REMOVED***;
var getSloppyArguments = Function('return arguments');

var collect = function createCollection(C, items) ***REMOVED***
	var c = new C();
	forEach(items, function (item) ***REMOVED***
		if (c.add) ***REMOVED***
			c.add(item);
		***REMOVED*** else ***REMOVED***
			c.set(item[0], item[1]);
		***REMOVED***
	***REMOVED***);
	return c;
***REMOVED***;

var runTests = function runTests(t) ***REMOVED***
	t.test('strings', function (st) ***REMOVED***
		st.iterate('', [], '"" yields nothing');
		st.iterate(Object(''), [], inspect(Object('')) + ' yields nothing');
		st.iterate('foo', ['f', 'o', 'o'], '"foo" yields three chars');
		st.iterate(Object('foo'), ['f', 'o', 'o'], inspect(Object('foo')) + ' yields three chars');
		st.iterate('aðŸ’©z', ['a', 'ðŸ’©', 'z'], '"aðŸ’©z" yields three code points');
		st.iterate(Object('aðŸ’©z'), ['a', 'ðŸ’©', 'z'], inspect(Object('aðŸ’©z')) + ' yields three code points');
		st.iterate('\ud83dX', ['\ud83d', 'X'], inspect('\ud83dX') + ' (lone surrogate followed by "not a lone surrogate ending") yields one code point');

		st.fakeIterator('abc');

		st.end();
	***REMOVED***);

	t.test('arrays', function (st) ***REMOVED***
		st.iterate([], [], '[] yields nothing');
		st.iterate([1, 2], [1, 2], '[1, 2] yields [1, 2]');
		// eslint-disable-next-line no-sparse-arrays
		st.iterate([1, , 3], [1, undefined, 3], 'sparse array does not skip holes');

		st.fakeIterator([1, 2, 3]);

		st.end();
	***REMOVED***);

	t.test('arguments', function (st) ***REMOVED***
		st.iterate(getArguments(), [], 'empty arguments object yields nothing');
		st.iterate(getSloppyArguments(), [], 'empty sloppy arguments object yields nothing');
		st.iterate(getArguments(1, 2, 3), [1, 2, 3], 'arguments object yields all args');
		st.iterate(getSloppyArguments(1, 2, 3), [1, 2, 3], 'sloppy arguments object yields all args');

		st.fakeIterator(getArguments(1, 2, 3));
		st.fakeIterator(getSloppyArguments(1, 2, 3));

		st.end();
	***REMOVED***);

	t.test('non-iterables', function (st) ***REMOVED***
		var numbers = [0, -0, NaN, Infinity, 42];
		var nonIterables = [
			undefined,
			null,
			true,
			false,
			***REMOVED******REMOVED***,
			/a/g,
			function () ***REMOVED******REMOVED***
		];
		if (hasSymbols) ***REMOVED***
			nonIterables.push(Symbol.iterator);
		***REMOVED***
		if (hasBigInts) ***REMOVED***
			nonIterables.push(BigInt(42), BigInt(0));
		***REMOVED***
		forEach(nonIterables, function (nonIterable) ***REMOVED***
			st.noIterate(nonIterable);
			if (nonIterable != null) ***REMOVED***
				st.fakeIterator(nonIterable);
			***REMOVED***
		***REMOVED***);
		if (hasSymbols && NaN[Symbol.iterator]) ***REMOVED***
			st.comment('# SKIP core-js v2 makes numbers iterable, in violation of the spec');
		***REMOVED***
		forEach(numbers, function (number) ***REMOVED***
			if (!hasSymbols || !number[Symbol.iterator]) ***REMOVED***
				st.noIterate(number);
			***REMOVED***
			st.fakeIterator(number);
		***REMOVED***);

		st.end();
	***REMOVED***);

	t.test('Map', ***REMOVED*** skip: typeof Map !== 'function' ***REMOVED***, function (st) ***REMOVED***
		st.iterate(new Map(), [], 'empty Map yields nothing');
		var entries = [
			[1, 'a'],
			[2, 'b'],
			[3, 'c']
		];
		var m = collect(Map, entries);
		st.iterate(m, entries, inspect(m) + ' yields expected entries');

		st.fakeIterator(collect(Map, entries));

		st.end();
	***REMOVED***);

	t.test('Set', ***REMOVED*** skip: typeof Set !== 'function' ***REMOVED***, function (st) ***REMOVED***
		st.iterate(new Set(), [], 'empty Set yields nothing');
		var values = [
			1,
			2,
			3
		];
		var s = collect(Set, values);
		st.iterate(s, values, inspect(s) + ' yields expected values');

		st.fakeIterator(collect(Set, values));

		st.end();
	***REMOVED***);
***REMOVED***;

test((process.env.TEST_VARIANT || 'standard') + ': getIterator tests', function (t) ***REMOVED***
	runTests(t);

	t.end();
***REMOVED***);
