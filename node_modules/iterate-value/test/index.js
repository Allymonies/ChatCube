'use strict';

var test = require('tape');
var forEach = require('for-each');
var hasSymbols = require('has-symbols')();
var hasBigInts = require('has-bigints')();
var debug = require('object-inspect');
var iterate = require('..');

function testIteration(t, iterable, expected, message) ***REMOVED***
	t.deepEqual(iterate(iterable), expected, 'no callback: ' + message);
	var values = [];
	iterate(iterable, function (x) ***REMOVED*** values.push(x); ***REMOVED***);
	t.deepEqual(values, expected, 'callback: ' + message);
	return values;
***REMOVED***

function testNonIterable(t, nonIterable, isNumber) ***REMOVED***
	t['throws'](function () ***REMOVED*** iterate(nonIterable); ***REMOVED***, TypeError, debug(nonIterable) + ' is not iterable');
	if (nonIterable != null && hasSymbols && (!isNumber || !nonIterable[Symbol.iterator])) ***REMOVED***
		var o = Object(nonIterable);
		o[Symbol.iterator] = function () ***REMOVED***
			return [1, 2, 3][Symbol.iterator]();
		***REMOVED***;
		testIteration(t, o, [1, 2, 3], 'fake iterator works on non-iterable ' + debug(o));
	***REMOVED***
***REMOVED***

function getArguments() ***REMOVED***
	return arguments;
***REMOVED***

test('non-iterables', function (t) ***REMOVED***
	var numbers = [0, -0, NaN, Infinity, 42];
	var nonIterables = [
		undefined,
		null,
		true,
		false,
		***REMOVED******REMOVED***,
		/a/g,
		function () ***REMOVED******REMOVED***
	];
	if (hasSymbols) ***REMOVED***
		nonIterables.push(Symbol.iterator);
	***REMOVED***
	if (hasBigInts) ***REMOVED***
		nonIterables.push(BigInt(42), BigInt(0));
	***REMOVED***
	forEach(nonIterables, function (nonIterable) ***REMOVED***
		testNonIterable(t, nonIterable);
	***REMOVED***);
	if (hasSymbols && NaN[Symbol.iterator]) ***REMOVED***
		t.comment('# SKIP core-js v2 makes numbers iterable, in violation of the spec');
	***REMOVED***
	forEach(numbers, function (number) ***REMOVED***
		testNonIterable(t, number, true);
	***REMOVED***);

	t.end();
***REMOVED***);

test('strings', function (t) ***REMOVED***
	testIteration(t, '', [], 'empty string');
	testIteration(t, 'abc', ['a', 'b', 'c'], debug('abc'));
	testIteration(t, 'aðŸ’©c', ['a', 'ðŸ’©', 'c'], debug('aðŸ’©c'));

	t.end();
***REMOVED***);

test('arrays', function (t) ***REMOVED***
	forEach([
		[],
		[1, 2, 3]
	], function (arr) ***REMOVED***
		testIteration(t, arr, arr, debug(arr));
	***REMOVED***);
	var sparse = [1, , 3]; // eslint-disable-line no-sparse-arrays
	var actual = testIteration(t, sparse, [1, undefined, 3], debug(sparse));
	t.ok(1 in actual, 'actual is not sparse');

	t.end();
***REMOVED***);

test('arguments', function (t) ***REMOVED***
	var empty = getArguments();
	testIteration(t, empty, [], debug(empty));

	var args = getArguments(1, 2, 3);
	testIteration(t, args, [1, 2, 3], debug(args));

	t.end();
***REMOVED***);

test('Maps', ***REMOVED*** skip: typeof Map !== 'function' ***REMOVED***, function (t) ***REMOVED***
	var empty = new Map();
	testIteration(t, empty, [], debug(empty));

	var m = new Map();
	m.set(1, 2);
	m.set(3, 4);
	testIteration(t, m, [[1, 2], [3, 4]], debug(m));

	t.end();
***REMOVED***);

test('Sets', ***REMOVED*** skip: typeof Set !== 'function' ***REMOVED***, function (t) ***REMOVED***
	var empty = new Set();
	testIteration(t, empty, [], debug(empty));

	var s = new Set();
	s.add(1);
	s.add(2);
	testIteration(t, s, [1, 2], debug(s));

	t.end();
***REMOVED***);

test('non-function callbacks', function (t) ***REMOVED***
	forEach([
		null,
		undefined,
		false,
		true,
		0,
		-0,
		NaN,
		42,
		Infinity,
		'',
		'abc',
		/a/g,
		[],
		***REMOVED******REMOVED***
	], function (nonFunction) ***REMOVED***
		t['throws'](
			function () ***REMOVED*** iterate([], nonFunction); ***REMOVED***,
			TypeError,
			debug(nonFunction) + ' is not a Function'
		);
	***REMOVED***);

	t.end();
***REMOVED***);
