'use strict';

/* globals Proxy */
/* eslint no-magic-numbers: 1 */

var test = require('tape');
var isCallable = require('../');
var hasToStringTag = require('has-tostringtag/shams')();
var v = require('es-value-fixtures');
var forEach = require('for-each');
var inspect = require('object-inspect');
var typedArrayNames = require('available-typed-arrays')();
var generators = require('make-generator-function')();
var arrows = require('make-arrow-function').list();
var asyncs = require('make-async-function').list();
var weirdlyCommentedArrowFn;
try ***REMOVED***
	/* eslint-disable no-new-func */
	weirdlyCommentedArrowFn = Function('return cl/*/**/=>/**/ass - 1;')();
	/* eslint-enable no-new-func */
***REMOVED*** catch (e) ***REMOVED*** /**/ ***REMOVED***

var noop = function () ***REMOVED******REMOVED***;
var classFake = function classFake() ***REMOVED*** ***REMOVED***; // eslint-disable-line func-name-matching
var returnClass = function () ***REMOVED*** return ' class '; ***REMOVED***;
var return3 = function () ***REMOVED*** return 3; ***REMOVED***;
/* for coverage */
noop();
classFake();
returnClass();
return3();
/* end for coverage */

var proxy;
if (typeof Proxy === 'function') ***REMOVED***
	try ***REMOVED***
		proxy = new Proxy(function () ***REMOVED******REMOVED***, ***REMOVED******REMOVED***);
		// for coverage
		proxy();
		String(proxy);
	***REMOVED*** catch (_) ***REMOVED***
		// If `Reflect` is supported, then `Function.prototype.toString` isn't used for callability detection.
		if (typeof Reflect !== 'object') ***REMOVED***
			// Older engines throw a `TypeError` when `Function.prototype.toString` is called on a Proxy object.
			proxy = null;
		***REMOVED***
	***REMOVED***
***REMOVED***

var invokeFunction = function invokeFunctionString(str) ***REMOVED***
	var result;
	try ***REMOVED***
		/* eslint-disable no-new-func */
		var fn = Function(str);
		/* eslint-enable no-new-func */
		result = fn();
	***REMOVED*** catch (e) ***REMOVED******REMOVED***
	return result;
***REMOVED***;

var classConstructor = invokeFunction('"use strict"; return class Foo ***REMOVED******REMOVED***');

var commentedClass = invokeFunction('"use strict"; return class/*kkk*/\n//blah\n Bar\n//blah\n ***REMOVED******REMOVED***');
var commentedClassOneLine = invokeFunction('"use strict"; return class/**/A***REMOVED******REMOVED***');
var classAnonymous = invokeFunction('"use strict"; return class***REMOVED******REMOVED***');
var classAnonymousCommentedOneLine = invokeFunction('"use strict"; return class/*/*/***REMOVED******REMOVED***');

test('not callables', function (t) ***REMOVED***
	t.notOk(isCallable(), 'implicit undefined is not callable');

	forEach(v.nonFunctions.concat([
		Object(42),
		Object('foo'),
		NaN,
		[],
		/a/g,
		new RegExp('a', 'g'),
		new Date()
	]), function (nonFunction) ***REMOVED***
		t.equal(isCallable(nonFunction), false, inspect(nonFunction) + ' is not callable');
	***REMOVED***);

	t.test('non-function with function in its [[Prototype]] chain', function (st) ***REMOVED***
		var Foo = function Bar() ***REMOVED******REMOVED***;
		Foo.prototype = noop;
		st.equal(isCallable(Foo), true, 'sanity check: Foo is callable');
		st.equal(isCallable(new Foo()), false, 'instance of Foo is not callable');
		st.end();
	***REMOVED***);

	t.end();
***REMOVED***);

test('@@toStringTag', ***REMOVED*** skip: !hasToStringTag ***REMOVED***, function (t) ***REMOVED***
	var fakeFunction = ***REMOVED***
		toString: function () ***REMOVED*** return String(return3); ***REMOVED***,
		valueOf: return3
	***REMOVED***;
	fakeFunction[Symbol.toStringTag] = 'Function';
	t.equal(String(fakeFunction), String(return3));
	t.equal(Number(fakeFunction), return3());
	t.notOk(isCallable(fakeFunction), 'fake Function with @@toStringTag "Function" is not callable');
	t.end();
***REMOVED***);

test('Functions', function (t) ***REMOVED***
	t.ok(isCallable(noop), 'function is callable');
	t.ok(isCallable(classFake), 'function with name containing "class" is callable');
	t.ok(isCallable(returnClass), 'function with string " class " is callable');
	t.ok(isCallable(isCallable), 'isCallable is callable');
	t.end();
***REMOVED***);

test('Typed Arrays', ***REMOVED*** skip: typedArrayNames.length === 0 ***REMOVED***, function (st) ***REMOVED***
	forEach(typedArrayNames, function (typedArray) ***REMOVED***
		st.ok(isCallable(global[typedArray]), typedArray + ' is callable');
	***REMOVED***);
	st.end();
***REMOVED***);

test('Generators', ***REMOVED*** skip: generators.length === 0 ***REMOVED***, function (t) ***REMOVED***
	forEach(generators, function (genFn) ***REMOVED***
		t.ok(isCallable(genFn), 'generator function ' + genFn + ' is callable');
	***REMOVED***);
	t.end();
***REMOVED***);

test('Arrow functions', ***REMOVED*** skip: arrows.length === 0 ***REMOVED***, function (t) ***REMOVED***
	forEach(arrows, function (arrowFn) ***REMOVED***
		t.ok(isCallable(arrowFn), 'arrow function ' + arrowFn + ' is callable');
	***REMOVED***);
	t.ok(isCallable(weirdlyCommentedArrowFn), 'weirdly commented arrow functions are callable');
	t.end();
***REMOVED***);

test('"Class" constructors', ***REMOVED*** skip: !classConstructor || !commentedClass || !commentedClassOneLine || !classAnonymous ***REMOVED***, function (t) ***REMOVED***
	t.notOk(isCallable(classConstructor), 'class constructors are not callable');
	t.notOk(isCallable(commentedClass), 'class constructors with comments in the signature are not callable');
	t.notOk(isCallable(commentedClassOneLine), 'one-line class constructors with comments in the signature are not callable');
	t.notOk(isCallable(classAnonymous), 'anonymous class constructors are not callable');
	t.notOk(isCallable(classAnonymousCommentedOneLine), 'anonymous one-line class constructors with comments in the signature are not callable');
	t.end();
***REMOVED***);

test('`async function`s', ***REMOVED*** skip: asyncs.length === 0 ***REMOVED***, function (t) ***REMOVED***
	forEach(asyncs, function (asyncFn) ***REMOVED***
		t.ok(isCallable(asyncFn), '`async function` ' + asyncFn + ' is callable');
	***REMOVED***);
	t.end();
***REMOVED***);

test('proxies of functions', ***REMOVED*** skip: !proxy ***REMOVED***, function (t) ***REMOVED***
	t.ok(isCallable(proxy), 'proxies of functions are callable');
	t.end();
***REMOVED***);

test('throwing functions', function (t) ***REMOVED***
	t.plan(1);

	var thrower = function (a) ***REMOVED*** return a.b; ***REMOVED***;
	t.ok(isCallable(thrower), 'a function that throws is callable');
***REMOVED***);

/* globals document: false */
test('document.all', ***REMOVED*** skip: typeof document !== 'object' ***REMOVED***, function (t) ***REMOVED***
	t.notOk(isCallable(document), 'document is not callable');
	t.ok(isCallable(document.all), 'document.all is callable');

	t.end();
***REMOVED***);
