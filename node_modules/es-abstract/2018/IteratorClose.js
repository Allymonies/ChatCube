'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = GetIntrinsic('%TypeError%');

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var Type = require('./Type');

// https://ecma-international.org/ecma-262/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) ***REMOVED***
	if (Type(iterator) !== 'Object') ***REMOVED***
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	***REMOVED***
	if (!IsCallable(completion)) ***REMOVED***
		throw new $TypeError('Assertion failed: completion is not a thunk for a Completion Record');
	***REMOVED***
	var completionThunk = completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') ***REMOVED***
		return completionThunk();
	***REMOVED***

	var completionRecord;
	try ***REMOVED***
		var innerResult = Call(iteratorReturn, iterator, []);
	***REMOVED*** catch (e) ***REMOVED***
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	***REMOVED***
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (Type(innerResult) !== 'Object') ***REMOVED***
		throw new $TypeError('iterator .return must return an object');
	***REMOVED***

	return completionRecord;
***REMOVED***;
