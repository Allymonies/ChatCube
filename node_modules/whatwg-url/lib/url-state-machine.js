"use strict";
const punycode = require("punycode");
const tr46 = require("tr46");

const specialSchemes = ***REMOVED***
  ftp: 21,
  file: null,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
***REMOVED***;

const failure = Symbol("failure");

function countSymbols(str) ***REMOVED***
  return punycode.ucs2.decode(str).length;
***REMOVED***

function at(input, idx) ***REMOVED***
  const c = input[idx];
  return isNaN(c) ? undefined : String.fromCodePoint(c);
***REMOVED***

function isASCIIDigit(c) ***REMOVED***
  return c >= 0x30 && c <= 0x39;
***REMOVED***

function isASCIIAlpha(c) ***REMOVED***
  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);
***REMOVED***

function isASCIIAlphanumeric(c) ***REMOVED***
  return isASCIIAlpha(c) || isASCIIDigit(c);
***REMOVED***

function isASCIIHex(c) ***REMOVED***
  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);
***REMOVED***

function isSingleDot(buffer) ***REMOVED***
  return buffer === "." || buffer.toLowerCase() === "%2e";
***REMOVED***

function isDoubleDot(buffer) ***REMOVED***
  buffer = buffer.toLowerCase();
  return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
***REMOVED***

function isWindowsDriveLetterCodePoints(cp1, cp2) ***REMOVED***
  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
***REMOVED***

function isWindowsDriveLetterString(string) ***REMOVED***
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
***REMOVED***

function isNormalizedWindowsDriveLetterString(string) ***REMOVED***
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
***REMOVED***

function containsForbiddenHostCodePoint(string) ***REMOVED***
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
***REMOVED***

function containsForbiddenHostCodePointExcludingPercent(string) ***REMOVED***
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
***REMOVED***

function isSpecialScheme(scheme) ***REMOVED***
  return specialSchemes[scheme] !== undefined;
***REMOVED***

function isSpecial(url) ***REMOVED***
  return isSpecialScheme(url.scheme);
***REMOVED***

function defaultPort(scheme) ***REMOVED***
  return specialSchemes[scheme];
***REMOVED***

function percentEncode(c) ***REMOVED***
  let hex = c.toString(16).toUpperCase();
  if (hex.length === 1) ***REMOVED***
    hex = "0" + hex;
  ***REMOVED***

  return "%" + hex;
***REMOVED***

function utf8PercentEncode(c) ***REMOVED***
  const buf = new Buffer(c);

  let str = "";

  for (let i = 0; i < buf.length; ++i) ***REMOVED***
    str += percentEncode(buf[i]);
  ***REMOVED***

  return str;
***REMOVED***

function utf8PercentDecode(str) ***REMOVED***
  const input = new Buffer(str);
  const output = [];
  for (let i = 0; i < input.length; ++i) ***REMOVED***
    if (input[i] !== 37) ***REMOVED***
      output.push(input[i]);
    ***REMOVED*** else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) ***REMOVED***
      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
      i += 2;
    ***REMOVED*** else ***REMOVED***
      output.push(input[i]);
    ***REMOVED***
  ***REMOVED***
  return new Buffer(output).toString();
***REMOVED***

function isC0ControlPercentEncode(c) ***REMOVED***
  return c <= 0x1F || c > 0x7E;
***REMOVED***

const extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
function isPathPercentEncode(c) ***REMOVED***
  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
***REMOVED***

const extraUserinfoPercentEncodeSet =
  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
function isUserinfoPercentEncode(c) ***REMOVED***
  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
***REMOVED***

function percentEncodeChar(c, encodeSetPredicate) ***REMOVED***
  const cStr = String.fromCodePoint(c);

  if (encodeSetPredicate(c)) ***REMOVED***
    return utf8PercentEncode(cStr);
  ***REMOVED***

  return cStr;
***REMOVED***

function parseIPv4Number(input) ***REMOVED***
  let R = 10;

  if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") ***REMOVED***
    input = input.substring(2);
    R = 16;
  ***REMOVED*** else if (input.length >= 2 && input.charAt(0) === "0") ***REMOVED***
    input = input.substring(1);
    R = 8;
  ***REMOVED***

  if (input === "") ***REMOVED***
    return 0;
  ***REMOVED***

  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);
  if (regex.test(input)) ***REMOVED***
    return failure;
  ***REMOVED***

  return parseInt(input, R);
***REMOVED***

function parseIPv4(input) ***REMOVED***
  const parts = input.split(".");
  if (parts[parts.length - 1] === "") ***REMOVED***
    if (parts.length > 1) ***REMOVED***
      parts.pop();
    ***REMOVED***
  ***REMOVED***

  if (parts.length > 4) ***REMOVED***
    return input;
  ***REMOVED***

  const numbers = [];
  for (const part of parts) ***REMOVED***
    if (part === "") ***REMOVED***
      return input;
    ***REMOVED***
    const n = parseIPv4Number(part);
    if (n === failure) ***REMOVED***
      return input;
    ***REMOVED***

    numbers.push(n);
  ***REMOVED***

  for (let i = 0; i < numbers.length - 1; ++i) ***REMOVED***
    if (numbers[i] > 255) ***REMOVED***
      return failure;
    ***REMOVED***
  ***REMOVED***
  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) ***REMOVED***
    return failure;
  ***REMOVED***

  let ipv4 = numbers.pop();
  let counter = 0;

  for (const n of numbers) ***REMOVED***
    ipv4 += n * Math.pow(256, 3 - counter);
    ++counter;
  ***REMOVED***

  return ipv4;
***REMOVED***

function serializeIPv4(address) ***REMOVED***
  let output = "";
  let n = address;

  for (let i = 1; i <= 4; ++i) ***REMOVED***
    output = String(n % 256) + output;
    if (i !== 4) ***REMOVED***
      output = "." + output;
    ***REMOVED***
    n = Math.floor(n / 256);
  ***REMOVED***

  return output;
***REMOVED***

function parseIPv6(input) ***REMOVED***
  const address = [0, 0, 0, 0, 0, 0, 0, 0];
  let pieceIndex = 0;
  let compress = null;
  let pointer = 0;

  input = punycode.ucs2.decode(input);

  if (input[pointer] === 58) ***REMOVED***
    if (input[pointer + 1] !== 58) ***REMOVED***
      return failure;
    ***REMOVED***

    pointer += 2;
    ++pieceIndex;
    compress = pieceIndex;
  ***REMOVED***

  while (pointer < input.length) ***REMOVED***
    if (pieceIndex === 8) ***REMOVED***
      return failure;
    ***REMOVED***

    if (input[pointer] === 58) ***REMOVED***
      if (compress !== null) ***REMOVED***
        return failure;
      ***REMOVED***
      ++pointer;
      ++pieceIndex;
      compress = pieceIndex;
      continue;
    ***REMOVED***

    let value = 0;
    let length = 0;

    while (length < 4 && isASCIIHex(input[pointer])) ***REMOVED***
      value = value * 0x10 + parseInt(at(input, pointer), 16);
      ++pointer;
      ++length;
    ***REMOVED***

    if (input[pointer] === 46) ***REMOVED***
      if (length === 0) ***REMOVED***
        return failure;
      ***REMOVED***

      pointer -= length;

      if (pieceIndex > 6) ***REMOVED***
        return failure;
      ***REMOVED***

      let numbersSeen = 0;

      while (input[pointer] !== undefined) ***REMOVED***
        let ipv4Piece = null;

        if (numbersSeen > 0) ***REMOVED***
          if (input[pointer] === 46 && numbersSeen < 4) ***REMOVED***
            ++pointer;
          ***REMOVED*** else ***REMOVED***
            return failure;
          ***REMOVED***
        ***REMOVED***

        if (!isASCIIDigit(input[pointer])) ***REMOVED***
          return failure;
        ***REMOVED***

        while (isASCIIDigit(input[pointer])) ***REMOVED***
          const number = parseInt(at(input, pointer));
          if (ipv4Piece === null) ***REMOVED***
            ipv4Piece = number;
          ***REMOVED*** else if (ipv4Piece === 0) ***REMOVED***
            return failure;
          ***REMOVED*** else ***REMOVED***
            ipv4Piece = ipv4Piece * 10 + number;
          ***REMOVED***
          if (ipv4Piece > 255) ***REMOVED***
            return failure;
          ***REMOVED***
          ++pointer;
        ***REMOVED***

        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;

        ++numbersSeen;

        if (numbersSeen === 2 || numbersSeen === 4) ***REMOVED***
          ++pieceIndex;
        ***REMOVED***
      ***REMOVED***

      if (numbersSeen !== 4) ***REMOVED***
        return failure;
      ***REMOVED***

      break;
    ***REMOVED*** else if (input[pointer] === 58) ***REMOVED***
      ++pointer;
      if (input[pointer] === undefined) ***REMOVED***
        return failure;
      ***REMOVED***
    ***REMOVED*** else if (input[pointer] !== undefined) ***REMOVED***
      return failure;
    ***REMOVED***

    address[pieceIndex] = value;
    ++pieceIndex;
  ***REMOVED***

  if (compress !== null) ***REMOVED***
    let swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 && swaps > 0) ***REMOVED***
      const temp = address[compress + swaps - 1];
      address[compress + swaps - 1] = address[pieceIndex];
      address[pieceIndex] = temp;
      --pieceIndex;
      --swaps;
    ***REMOVED***
  ***REMOVED*** else if (compress === null && pieceIndex !== 8) ***REMOVED***
    return failure;
  ***REMOVED***

  return address;
***REMOVED***

function serializeIPv6(address) ***REMOVED***
  let output = "";
  const seqResult = findLongestZeroSequence(address);
  const compress = seqResult.idx;
  let ignore0 = false;

  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) ***REMOVED***
    if (ignore0 && address[pieceIndex] === 0) ***REMOVED***
      continue;
    ***REMOVED*** else if (ignore0) ***REMOVED***
      ignore0 = false;
    ***REMOVED***

    if (compress === pieceIndex) ***REMOVED***
      const separator = pieceIndex === 0 ? "::" : ":";
      output += separator;
      ignore0 = true;
      continue;
    ***REMOVED***

    output += address[pieceIndex].toString(16);

    if (pieceIndex !== 7) ***REMOVED***
      output += ":";
    ***REMOVED***
  ***REMOVED***

  return output;
***REMOVED***

function parseHost(input, isSpecialArg) ***REMOVED***
  if (input[0] === "[") ***REMOVED***
    if (input[input.length - 1] !== "]") ***REMOVED***
      return failure;
    ***REMOVED***

    return parseIPv6(input.substring(1, input.length - 1));
  ***REMOVED***

  if (!isSpecialArg) ***REMOVED***
    return parseOpaqueHost(input);
  ***REMOVED***

  const domain = utf8PercentDecode(input);
  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
  if (asciiDomain === null) ***REMOVED***
    return failure;
  ***REMOVED***

  if (containsForbiddenHostCodePoint(asciiDomain)) ***REMOVED***
    return failure;
  ***REMOVED***

  const ipv4Host = parseIPv4(asciiDomain);
  if (typeof ipv4Host === "number" || ipv4Host === failure) ***REMOVED***
    return ipv4Host;
  ***REMOVED***

  return asciiDomain;
***REMOVED***

function parseOpaqueHost(input) ***REMOVED***
  if (containsForbiddenHostCodePointExcludingPercent(input)) ***REMOVED***
    return failure;
  ***REMOVED***

  let output = "";
  const decoded = punycode.ucs2.decode(input);
  for (let i = 0; i < decoded.length; ++i) ***REMOVED***
    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
  ***REMOVED***
  return output;
***REMOVED***

function findLongestZeroSequence(arr) ***REMOVED***
  let maxIdx = null;
  let maxLen = 1; // only find elements > 1
  let currStart = null;
  let currLen = 0;

  for (let i = 0; i < arr.length; ++i) ***REMOVED***
    if (arr[i] !== 0) ***REMOVED***
      if (currLen > maxLen) ***REMOVED***
        maxIdx = currStart;
        maxLen = currLen;
      ***REMOVED***

      currStart = null;
      currLen = 0;
    ***REMOVED*** else ***REMOVED***
      if (currStart === null) ***REMOVED***
        currStart = i;
      ***REMOVED***
      ++currLen;
    ***REMOVED***
  ***REMOVED***

  // if trailing zeros
  if (currLen > maxLen) ***REMOVED***
    maxIdx = currStart;
    maxLen = currLen;
  ***REMOVED***

  return ***REMOVED***
    idx: maxIdx,
    len: maxLen
  ***REMOVED***;
***REMOVED***

function serializeHost(host) ***REMOVED***
  if (typeof host === "number") ***REMOVED***
    return serializeIPv4(host);
  ***REMOVED***

  // IPv6 serializer
  if (host instanceof Array) ***REMOVED***
    return "[" + serializeIPv6(host) + "]";
  ***REMOVED***

  return host;
***REMOVED***

function trimControlChars(url) ***REMOVED***
  return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
***REMOVED***

function trimTabAndNewline(url) ***REMOVED***
  return url.replace(/\u0009|\u000A|\u000D/g, "");
***REMOVED***

function shortenPath(url) ***REMOVED***
  const path = url.path;
  if (path.length === 0) ***REMOVED***
    return;
  ***REMOVED***
  if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) ***REMOVED***
    return;
  ***REMOVED***

  path.pop();
***REMOVED***

function includesCredentials(url) ***REMOVED***
  return url.username !== "" || url.password !== "";
***REMOVED***

function cannotHaveAUsernamePasswordPort(url) ***REMOVED***
  return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
***REMOVED***

function isNormalizedWindowsDriveLetter(string) ***REMOVED***
  return /^[A-Za-z]:$/.test(string);
***REMOVED***

function URLStateMachine(input, base, encodingOverride, url, stateOverride) ***REMOVED***
  this.pointer = 0;
  this.input = input;
  this.base = base || null;
  this.encodingOverride = encodingOverride || "utf-8";
  this.stateOverride = stateOverride;
  this.url = url;
  this.failure = false;
  this.parseError = false;

  if (!this.url) ***REMOVED***
    this.url = ***REMOVED***
      scheme: "",
      username: "",
      password: "",
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,

      cannotBeABaseURL: false
    ***REMOVED***;

    const res = trimControlChars(this.input);
    if (res !== this.input) ***REMOVED***
      this.parseError = true;
    ***REMOVED***
    this.input = res;
  ***REMOVED***

  const res = trimTabAndNewline(this.input);
  if (res !== this.input) ***REMOVED***
    this.parseError = true;
  ***REMOVED***
  this.input = res;

  this.state = stateOverride || "scheme start";

  this.buffer = "";
  this.atFlag = false;
  this.arrFlag = false;
  this.passwordTokenSeenFlag = false;

  this.input = punycode.ucs2.decode(this.input);

  for (; this.pointer <= this.input.length; ++this.pointer) ***REMOVED***
    const c = this.input[this.pointer];
    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);

    // exec state machine
    const ret = this["parse " + this.state](c, cStr);
    if (!ret) ***REMOVED***
      break; // terminate algorithm
    ***REMOVED*** else if (ret === failure) ***REMOVED***
      this.failure = true;
      break;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) ***REMOVED***
  if (isASCIIAlpha(c)) ***REMOVED***
    this.buffer += cStr.toLowerCase();
    this.state = "scheme";
  ***REMOVED*** else if (!this.stateOverride) ***REMOVED***
    this.state = "no scheme";
    --this.pointer;
  ***REMOVED*** else ***REMOVED***
    this.parseError = true;
    return failure;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) ***REMOVED***
  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) ***REMOVED***
    this.buffer += cStr.toLowerCase();
  ***REMOVED*** else if (c === 58) ***REMOVED***
    if (this.stateOverride) ***REMOVED***
      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) ***REMOVED***
        return false;
      ***REMOVED***

      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) ***REMOVED***
        return false;
      ***REMOVED***

      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") ***REMOVED***
        return false;
      ***REMOVED***

      if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED***
    this.url.scheme = this.buffer;
    this.buffer = "";
    if (this.stateOverride) ***REMOVED***
      return false;
    ***REMOVED***
    if (this.url.scheme === "file") ***REMOVED***
      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) ***REMOVED***
        this.parseError = true;
      ***REMOVED***
      this.state = "file";
    ***REMOVED*** else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) ***REMOVED***
      this.state = "special relative or authority";
    ***REMOVED*** else if (isSpecial(this.url)) ***REMOVED***
      this.state = "special authority slashes";
    ***REMOVED*** else if (this.input[this.pointer + 1] === 47) ***REMOVED***
      this.state = "path or authority";
      ++this.pointer;
    ***REMOVED*** else ***REMOVED***
      this.url.cannotBeABaseURL = true;
      this.url.path.push("");
      this.state = "cannot-be-a-base-URL path";
    ***REMOVED***
  ***REMOVED*** else if (!this.stateOverride) ***REMOVED***
    this.buffer = "";
    this.state = "no scheme";
    this.pointer = -1;
  ***REMOVED*** else ***REMOVED***
    this.parseError = true;
    return failure;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) ***REMOVED***
  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) ***REMOVED***
    return failure;
  ***REMOVED*** else if (this.base.cannotBeABaseURL && c === 35) ***REMOVED***
    this.url.scheme = this.base.scheme;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = "";
    this.url.cannotBeABaseURL = true;
    this.state = "fragment";
  ***REMOVED*** else if (this.base.scheme === "file") ***REMOVED***
    this.state = "file";
    --this.pointer;
  ***REMOVED*** else ***REMOVED***
    this.state = "relative";
    --this.pointer;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) ***REMOVED***
  if (c === 47 && this.input[this.pointer + 1] === 47) ***REMOVED***
    this.state = "special authority ignore slashes";
    ++this.pointer;
  ***REMOVED*** else ***REMOVED***
    this.parseError = true;
    this.state = "relative";
    --this.pointer;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) ***REMOVED***
  if (c === 47) ***REMOVED***
    this.state = "authority";
  ***REMOVED*** else ***REMOVED***
    this.state = "path";
    --this.pointer;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse relative"] = function parseRelative(c) ***REMOVED***
  this.url.scheme = this.base.scheme;
  if (isNaN(c)) ***REMOVED***
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
  ***REMOVED*** else if (c === 47) ***REMOVED***
    this.state = "relative slash";
  ***REMOVED*** else if (c === 63) ***REMOVED***
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = "";
    this.state = "query";
  ***REMOVED*** else if (c === 35) ***REMOVED***
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = "";
    this.state = "fragment";
  ***REMOVED*** else if (isSpecial(this.url) && c === 92) ***REMOVED***
    this.parseError = true;
    this.state = "relative slash";
  ***REMOVED*** else ***REMOVED***
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice(0, this.base.path.length - 1);

    this.state = "path";
    --this.pointer;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) ***REMOVED***
  if (isSpecial(this.url) && (c === 47 || c === 92)) ***REMOVED***
    if (c === 92) ***REMOVED***
      this.parseError = true;
    ***REMOVED***
    this.state = "special authority ignore slashes";
  ***REMOVED*** else if (c === 47) ***REMOVED***
    this.state = "authority";
  ***REMOVED*** else ***REMOVED***
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.state = "path";
    --this.pointer;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) ***REMOVED***
  if (c === 47 && this.input[this.pointer + 1] === 47) ***REMOVED***
    this.state = "special authority ignore slashes";
    ++this.pointer;
  ***REMOVED*** else ***REMOVED***
    this.parseError = true;
    this.state = "special authority ignore slashes";
    --this.pointer;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) ***REMOVED***
  if (c !== 47 && c !== 92) ***REMOVED***
    this.state = "authority";
    --this.pointer;
  ***REMOVED*** else ***REMOVED***
    this.parseError = true;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) ***REMOVED***
  if (c === 64) ***REMOVED***
    this.parseError = true;
    if (this.atFlag) ***REMOVED***
      this.buffer = "%40" + this.buffer;
    ***REMOVED***
    this.atFlag = true;

    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
    const len = countSymbols(this.buffer);
    for (let pointer = 0; pointer < len; ++pointer) ***REMOVED***
      const codePoint = this.buffer.codePointAt(pointer);

      if (codePoint === 58 && !this.passwordTokenSeenFlag) ***REMOVED***
        this.passwordTokenSeenFlag = true;
        continue;
      ***REMOVED***
      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
      if (this.passwordTokenSeenFlag) ***REMOVED***
        this.url.password += encodedCodePoints;
      ***REMOVED*** else ***REMOVED***
        this.url.username += encodedCodePoints;
      ***REMOVED***
    ***REMOVED***
    this.buffer = "";
  ***REMOVED*** else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92)) ***REMOVED***
    if (this.atFlag && this.buffer === "") ***REMOVED***
      this.parseError = true;
      return failure;
    ***REMOVED***
    this.pointer -= countSymbols(this.buffer) + 1;
    this.buffer = "";
    this.state = "host";
  ***REMOVED*** else ***REMOVED***
    this.buffer += cStr;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse hostname"] =
URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) ***REMOVED***
  if (this.stateOverride && this.url.scheme === "file") ***REMOVED***
    --this.pointer;
    this.state = "file host";
  ***REMOVED*** else if (c === 58 && !this.arrFlag) ***REMOVED***
    if (this.buffer === "") ***REMOVED***
      this.parseError = true;
      return failure;
    ***REMOVED***

    const host = parseHost(this.buffer, isSpecial(this.url));
    if (host === failure) ***REMOVED***
      return failure;
    ***REMOVED***

    this.url.host = host;
    this.buffer = "";
    this.state = "port";
    if (this.stateOverride === "hostname") ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED*** else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92)) ***REMOVED***
    --this.pointer;
    if (isSpecial(this.url) && this.buffer === "") ***REMOVED***
      this.parseError = true;
      return failure;
    ***REMOVED*** else if (this.stateOverride && this.buffer === "" &&
               (includesCredentials(this.url) || this.url.port !== null)) ***REMOVED***
      this.parseError = true;
      return false;
    ***REMOVED***

    const host = parseHost(this.buffer, isSpecial(this.url));
    if (host === failure) ***REMOVED***
      return failure;
    ***REMOVED***

    this.url.host = host;
    this.buffer = "";
    this.state = "path start";
    if (this.stateOverride) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    if (c === 91) ***REMOVED***
      this.arrFlag = true;
    ***REMOVED*** else if (c === 93) ***REMOVED***
      this.arrFlag = false;
    ***REMOVED***
    this.buffer += cStr;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) ***REMOVED***
  if (isASCIIDigit(c)) ***REMOVED***
    this.buffer += cStr;
  ***REMOVED*** else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92) ||
             this.stateOverride) ***REMOVED***
    if (this.buffer !== "") ***REMOVED***
      const port = parseInt(this.buffer);
      if (port > Math.pow(2, 16) - 1) ***REMOVED***
        this.parseError = true;
        return failure;
      ***REMOVED***
      this.url.port = port === defaultPort(this.url.scheme) ? null : port;
      this.buffer = "";
    ***REMOVED***
    if (this.stateOverride) ***REMOVED***
      return false;
    ***REMOVED***
    this.state = "path start";
    --this.pointer;
  ***REMOVED*** else ***REMOVED***
    this.parseError = true;
    return failure;
  ***REMOVED***

  return true;
***REMOVED***;

const fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);

URLStateMachine.prototype["parse file"] = function parseFile(c) ***REMOVED***
  this.url.scheme = "file";

  if (c === 47 || c === 92) ***REMOVED***
    if (c === 92) ***REMOVED***
      this.parseError = true;
    ***REMOVED***
    this.state = "file slash";
  ***REMOVED*** else if (this.base !== null && this.base.scheme === "file") ***REMOVED***
    if (isNaN(c)) ***REMOVED***
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    ***REMOVED*** else if (c === 63) ***REMOVED***
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    ***REMOVED*** else if (c === 35) ***REMOVED***
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    ***REMOVED*** else ***REMOVED***
      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||
          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) ***REMOVED***
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        shortenPath(this.url);
      ***REMOVED*** else ***REMOVED***
        this.parseError = true;
      ***REMOVED***

      this.state = "path";
      --this.pointer;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    this.state = "path";
    --this.pointer;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) ***REMOVED***
  if (c === 47 || c === 92) ***REMOVED***
    if (c === 92) ***REMOVED***
      this.parseError = true;
    ***REMOVED***
    this.state = "file host";
  ***REMOVED*** else ***REMOVED***
    if (this.base !== null && this.base.scheme === "file") ***REMOVED***
      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) ***REMOVED***
        this.url.path.push(this.base.path[0]);
      ***REMOVED*** else ***REMOVED***
        this.url.host = this.base.host;
      ***REMOVED***
    ***REMOVED***
    this.state = "path";
    --this.pointer;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) ***REMOVED***
  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) ***REMOVED***
    --this.pointer;
    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) ***REMOVED***
      this.parseError = true;
      this.state = "path";
    ***REMOVED*** else if (this.buffer === "") ***REMOVED***
      this.url.host = "";
      if (this.stateOverride) ***REMOVED***
        return false;
      ***REMOVED***
      this.state = "path start";
    ***REMOVED*** else ***REMOVED***
      let host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) ***REMOVED***
        return failure;
      ***REMOVED***
      if (host === "localhost") ***REMOVED***
        host = "";
      ***REMOVED***
      this.url.host = host;

      if (this.stateOverride) ***REMOVED***
        return false;
      ***REMOVED***

      this.buffer = "";
      this.state = "path start";
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    this.buffer += cStr;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse path start"] = function parsePathStart(c) ***REMOVED***
  if (isSpecial(this.url)) ***REMOVED***
    if (c === 92) ***REMOVED***
      this.parseError = true;
    ***REMOVED***
    this.state = "path";

    if (c !== 47 && c !== 92) ***REMOVED***
      --this.pointer;
    ***REMOVED***
  ***REMOVED*** else if (!this.stateOverride && c === 63) ***REMOVED***
    this.url.query = "";
    this.state = "query";
  ***REMOVED*** else if (!this.stateOverride && c === 35) ***REMOVED***
    this.url.fragment = "";
    this.state = "fragment";
  ***REMOVED*** else if (c !== undefined) ***REMOVED***
    this.state = "path";
    if (c !== 47) ***REMOVED***
      --this.pointer;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse path"] = function parsePath(c) ***REMOVED***
  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||
      (!this.stateOverride && (c === 63 || c === 35))) ***REMOVED***
    if (isSpecial(this.url) && c === 92) ***REMOVED***
      this.parseError = true;
    ***REMOVED***

    if (isDoubleDot(this.buffer)) ***REMOVED***
      shortenPath(this.url);
      if (c !== 47 && !(isSpecial(this.url) && c === 92)) ***REMOVED***
        this.url.path.push("");
      ***REMOVED***
    ***REMOVED*** else if (isSingleDot(this.buffer) && c !== 47 &&
               !(isSpecial(this.url) && c === 92)) ***REMOVED***
      this.url.path.push("");
    ***REMOVED*** else if (!isSingleDot(this.buffer)) ***REMOVED***
      if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) ***REMOVED***
        if (this.url.host !== "" && this.url.host !== null) ***REMOVED***
          this.parseError = true;
          this.url.host = "";
        ***REMOVED***
        this.buffer = this.buffer[0] + ":";
      ***REMOVED***
      this.url.path.push(this.buffer);
    ***REMOVED***
    this.buffer = "";
    if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) ***REMOVED***
      while (this.url.path.length > 1 && this.url.path[0] === "") ***REMOVED***
        this.parseError = true;
        this.url.path.shift();
      ***REMOVED***
    ***REMOVED***
    if (c === 63) ***REMOVED***
      this.url.query = "";
      this.state = "query";
    ***REMOVED***
    if (c === 35) ***REMOVED***
      this.url.fragment = "";
      this.state = "fragment";
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    // TODO: If c is not a URL code point and not "%", parse error.

    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) ***REMOVED***
      this.parseError = true;
    ***REMOVED***

    this.buffer += percentEncodeChar(c, isPathPercentEncode);
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) ***REMOVED***
  if (c === 63) ***REMOVED***
    this.url.query = "";
    this.state = "query";
  ***REMOVED*** else if (c === 35) ***REMOVED***
    this.url.fragment = "";
    this.state = "fragment";
  ***REMOVED*** else ***REMOVED***
    // TODO: Add: not a URL code point
    if (!isNaN(c) && c !== 37) ***REMOVED***
      this.parseError = true;
    ***REMOVED***

    if (c === 37 &&
        (!isASCIIHex(this.input[this.pointer + 1]) ||
         !isASCIIHex(this.input[this.pointer + 2]))) ***REMOVED***
      this.parseError = true;
    ***REMOVED***

    if (!isNaN(c)) ***REMOVED***
      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) ***REMOVED***
  if (isNaN(c) || (!this.stateOverride && c === 35)) ***REMOVED***
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") ***REMOVED***
      this.encodingOverride = "utf-8";
    ***REMOVED***

    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
    for (let i = 0; i < buffer.length; ++i) ***REMOVED***
      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||
          buffer[i] === 0x3C || buffer[i] === 0x3E) ***REMOVED***
        this.url.query += percentEncode(buffer[i]);
      ***REMOVED*** else ***REMOVED***
        this.url.query += String.fromCodePoint(buffer[i]);
      ***REMOVED***
    ***REMOVED***

    this.buffer = "";
    if (c === 35) ***REMOVED***
      this.url.fragment = "";
      this.state = "fragment";
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) ***REMOVED***
      this.parseError = true;
    ***REMOVED***

    this.buffer += cStr;
  ***REMOVED***

  return true;
***REMOVED***;

URLStateMachine.prototype["parse fragment"] = function parseFragment(c) ***REMOVED***
  if (isNaN(c)) ***REMOVED*** // do nothing
  ***REMOVED*** else if (c === 0x0) ***REMOVED***
    this.parseError = true;
  ***REMOVED*** else ***REMOVED***
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) ***REMOVED***
      this.parseError = true;
    ***REMOVED***

    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
  ***REMOVED***

  return true;
***REMOVED***;

function serializeURL(url, excludeFragment) ***REMOVED***
  let output = url.scheme + ":";
  if (url.host !== null) ***REMOVED***
    output += "//";

    if (url.username !== "" || url.password !== "") ***REMOVED***
      output += url.username;
      if (url.password !== "") ***REMOVED***
        output += ":" + url.password;
      ***REMOVED***
      output += "@";
    ***REMOVED***

    output += serializeHost(url.host);

    if (url.port !== null) ***REMOVED***
      output += ":" + url.port;
    ***REMOVED***
  ***REMOVED*** else if (url.host === null && url.scheme === "file") ***REMOVED***
    output += "//";
  ***REMOVED***

  if (url.cannotBeABaseURL) ***REMOVED***
    output += url.path[0];
  ***REMOVED*** else ***REMOVED***
    for (const string of url.path) ***REMOVED***
      output += "/" + string;
    ***REMOVED***
  ***REMOVED***

  if (url.query !== null) ***REMOVED***
    output += "?" + url.query;
  ***REMOVED***

  if (!excludeFragment && url.fragment !== null) ***REMOVED***
    output += "#" + url.fragment;
  ***REMOVED***

  return output;
***REMOVED***

function serializeOrigin(tuple) ***REMOVED***
  let result = tuple.scheme + "://";
  result += serializeHost(tuple.host);

  if (tuple.port !== null) ***REMOVED***
    result += ":" + tuple.port;
  ***REMOVED***

  return result;
***REMOVED***

module.exports.serializeURL = serializeURL;

module.exports.serializeURLOrigin = function (url) ***REMOVED***
  // https://url.spec.whatwg.org/#concept-url-origin
  switch (url.scheme) ***REMOVED***
    case "blob":
      try ***REMOVED***
        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
      ***REMOVED*** catch (e) ***REMOVED***
        // serializing an opaque origin returns "null"
        return "null";
      ***REMOVED***
    case "ftp":
    case "gopher":
    case "http":
    case "https":
    case "ws":
    case "wss":
      return serializeOrigin(***REMOVED***
        scheme: url.scheme,
        host: url.host,
        port: url.port
      ***REMOVED***);
    case "file":
      // spec says "exercise to the reader", chrome says "file://"
      return "file://";
    default:
      // serializing an opaque origin returns "null"
      return "null";
  ***REMOVED***
***REMOVED***;

module.exports.basicURLParse = function (input, options) ***REMOVED***
  if (options === undefined) ***REMOVED***
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
  if (usm.failure) ***REMOVED***
    return "failure";
  ***REMOVED***

  return usm.url;
***REMOVED***;

module.exports.setTheUsername = function (url, username) ***REMOVED***
  url.username = "";
  const decoded = punycode.ucs2.decode(username);
  for (let i = 0; i < decoded.length; ++i) ***REMOVED***
    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  ***REMOVED***
***REMOVED***;

module.exports.setThePassword = function (url, password) ***REMOVED***
  url.password = "";
  const decoded = punycode.ucs2.decode(password);
  for (let i = 0; i < decoded.length; ++i) ***REMOVED***
    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  ***REMOVED***
***REMOVED***;

module.exports.serializeHost = serializeHost;

module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;

module.exports.serializeInteger = function (integer) ***REMOVED***
  return String(integer);
***REMOVED***;

module.exports.parseURL = function (input, options) ***REMOVED***
  if (options === undefined) ***REMOVED***
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  // We don't handle blobs, so this just delegates:
  return module.exports.basicURLParse(input, ***REMOVED*** baseURL: options.baseURL, encodingOverride: options.encodingOverride ***REMOVED***);
***REMOVED***;
