'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var whichBoxedPrimitive = require('..');

var debug = function (v, m) ***REMOVED*** return inspect(v) + ' ' + m; ***REMOVED***;

var forEach = function (arr, func) ***REMOVED***
	var i;
	for (i = 0; i < arr.length; ++i) ***REMOVED***
		func(arr[i], i, arr);
	***REMOVED***
***REMOVED***;

var hasSymbols = require('has-symbols')();
var hasBigInts = typeof BigInt === 'function';

var primitives = [
	true,
	false,
	42,
	NaN,
	Infinity,
	'',
	'foo'
].concat(
	hasSymbols ? [Symbol(), Symbol.iterator] : [],
	hasBigInts ? BigInt(42) : []
);

var objects = [
	/a/g,
	new Date(),
	function () ***REMOVED******REMOVED***,
	[],
	***REMOVED******REMOVED***
];

test('isBoxedPrimitive', function (t) ***REMOVED***
	t.test('unboxed primitives', function (st) ***REMOVED***
		forEach([null, undefined].concat(primitives), function (primitive) ***REMOVED***
			st.equal(null, whichBoxedPrimitive(primitive), debug(primitive, 'is a primitive, but not a boxed primitive'));
		***REMOVED***);
		st.end();
	***REMOVED***);

	t.test('boxed primitives', function (st) ***REMOVED***
		forEach(primitives, function (primitive) ***REMOVED***
			var boxed = Object(primitive);
			var expected = boxed.constructor.name;
			st.equal(typeof expected, 'string', 'expected is string');
			st.equal(whichBoxedPrimitive(boxed), expected, debug(boxed, 'is a boxed primitive: ' + expected));
		***REMOVED***);
		st.end();
	***REMOVED***);

	t.test('non-primitive objects', function (st) ***REMOVED***
		forEach(objects, function (object) ***REMOVED***
			st.equal(undefined, whichBoxedPrimitive(object), debug(object, 'is not a primitive, boxed or otherwise'));
		***REMOVED***);
		st.end();
	***REMOVED***);

	t.end();
***REMOVED***);
