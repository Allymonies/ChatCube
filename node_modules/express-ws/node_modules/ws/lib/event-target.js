'use strict';

/**
 * Class representing an event.
 *
 * @private
 */
class Event ***REMOVED***
  /**
   * Create a new `Event`.
   *
   * @param ***REMOVED***String***REMOVED*** type The name of the event
   * @param ***REMOVED***Object***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(type, target) ***REMOVED***
    this.target = target;
    this.type = type;
  ***REMOVED***
***REMOVED***

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event ***REMOVED***
  /**
   * Create a new `MessageEvent`.
   *
   * @param ***REMOVED***(String|Buffer|ArrayBuffer|Buffer[])***REMOVED*** data The received data
   * @param ***REMOVED***WebSocket***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(data, target) ***REMOVED***
    super('message', target);

    this.data = data;
  ***REMOVED***
***REMOVED***

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event ***REMOVED***
  /**
   * Create a new `CloseEvent`.
   *
   * @param ***REMOVED***Number***REMOVED*** code The status code explaining why the connection is being
   *     closed
   * @param ***REMOVED***String***REMOVED*** reason A human-readable string explaining why the
   *     connection is closing
   * @param ***REMOVED***WebSocket***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(code, reason, target) ***REMOVED***
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  ***REMOVED***
***REMOVED***

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event ***REMOVED***
  /**
   * Create a new `OpenEvent`.
   *
   * @param ***REMOVED***WebSocket***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(target) ***REMOVED***
    super('open', target);
  ***REMOVED***
***REMOVED***

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event ***REMOVED***
  /**
   * Create a new `ErrorEvent`.
   *
   * @param ***REMOVED***Object***REMOVED*** error The error that generated this event
   * @param ***REMOVED***WebSocket***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(error, target) ***REMOVED***
    super('error', target);

    this.message = error.message;
    this.error = error;
  ***REMOVED***
***REMOVED***

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = ***REMOVED***
  /**
   * Register an event listener.
   *
   * @param ***REMOVED***String***REMOVED*** type A string representing the event type to listen for
   * @param ***REMOVED***Function***REMOVED*** listener The listener to add
   * @param ***REMOVED***Object***REMOVED*** [options] An options object specifies characteristics about
   *     the event listener
   * @param ***REMOVED***Boolean***REMOVED*** [options.once=false] A `Boolean`` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options) ***REMOVED***
    if (typeof listener !== 'function') return;

    function onMessage(data) ***REMOVED***
      listener.call(this, new MessageEvent(data, this));
    ***REMOVED***

    function onClose(code, message) ***REMOVED***
      listener.call(this, new CloseEvent(code, message, this));
    ***REMOVED***

    function onError(error) ***REMOVED***
      listener.call(this, new ErrorEvent(error, this));
    ***REMOVED***

    function onOpen() ***REMOVED***
      listener.call(this, new OpenEvent(this));
    ***REMOVED***

    const method = options && options.once ? 'once' : 'on';

    if (type === 'message') ***REMOVED***
      onMessage._listener = listener;
      this[method](type, onMessage);
    ***REMOVED*** else if (type === 'close') ***REMOVED***
      onClose._listener = listener;
      this[method](type, onClose);
    ***REMOVED*** else if (type === 'error') ***REMOVED***
      onError._listener = listener;
      this[method](type, onError);
    ***REMOVED*** else if (type === 'open') ***REMOVED***
      onOpen._listener = listener;
      this[method](type, onOpen);
    ***REMOVED*** else ***REMOVED***
      this[method](type, listener);
    ***REMOVED***
  ***REMOVED***,

  /**
   * Remove an event listener.
   *
   * @param ***REMOVED***String***REMOVED*** type A string representing the event type to remove
   * @param ***REMOVED***Function***REMOVED*** listener The listener to remove
   * @public
   */
  removeEventListener(type, listener) ***REMOVED***
    const listeners = this.listeners(type);

    for (let i = 0; i < listeners.length; i++) ***REMOVED***
      if (listeners[i] === listener || listeners[i]._listener === listener) ***REMOVED***
        this.removeListener(type, listeners[i]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

module.exports = EventTarget;
