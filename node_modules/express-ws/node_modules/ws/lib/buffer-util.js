'use strict';

const ***REMOVED*** EMPTY_BUFFER ***REMOVED*** = require('./constants');

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param ***REMOVED***Buffer[]***REMOVED*** list The array of buffers to concat
 * @param ***REMOVED***Number***REMOVED*** totalLength The total length of buffers in the list
 * @return ***REMOVED***Buffer***REMOVED*** The resulting buffer
 * @public
 */
function concat(list, totalLength) ***REMOVED***
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) ***REMOVED***
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  ***REMOVED***

  if (offset < totalLength) return target.slice(0, offset);

  return target;
***REMOVED***

/**
 * Masks a buffer using the given mask.
 *
 * @param ***REMOVED***Buffer***REMOVED*** source The buffer to mask
 * @param ***REMOVED***Buffer***REMOVED*** mask The mask to use
 * @param ***REMOVED***Buffer***REMOVED*** output The buffer where to store the result
 * @param ***REMOVED***Number***REMOVED*** offset The offset at which to start writing
 * @param ***REMOVED***Number***REMOVED*** length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) ***REMOVED***
  for (let i = 0; i < length; i++) ***REMOVED***
    output[offset + i] = source[i] ^ mask[i & 3];
  ***REMOVED***
***REMOVED***

/**
 * Unmasks a buffer using the given mask.
 *
 * @param ***REMOVED***Buffer***REMOVED*** buffer The buffer to unmask
 * @param ***REMOVED***Buffer***REMOVED*** mask The mask to use
 * @public
 */
function _unmask(buffer, mask) ***REMOVED***
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (let i = 0; i < length; i++) ***REMOVED***
    buffer[i] ^= mask[i & 3];
  ***REMOVED***
***REMOVED***

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param ***REMOVED***Buffer***REMOVED*** buf The buffer to convert
 * @return ***REMOVED***ArrayBuffer***REMOVED*** Converted buffer
 * @public
 */
function toArrayBuffer(buf) ***REMOVED***
  if (buf.byteLength === buf.buffer.byteLength) ***REMOVED***
    return buf.buffer;
  ***REMOVED***

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
***REMOVED***

/**
 * Converts `data` to a `Buffer`.
 *
 * @param ***REMOVED*******REMOVED*** data The data to convert
 * @return ***REMOVED***Buffer***REMOVED*** The buffer
 * @throws ***REMOVED***TypeError***REMOVED***
 * @public
 */
function toBuffer(data) ***REMOVED***
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) ***REMOVED***
    buf = Buffer.from(data);
  ***REMOVED*** else if (ArrayBuffer.isView(data)) ***REMOVED***
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  ***REMOVED*** else ***REMOVED***
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  ***REMOVED***

  return buf;
***REMOVED***

try ***REMOVED***
  const bufferUtil = require('bufferutil');
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = ***REMOVED***
    concat,
    mask(source, mask, output, offset, length) ***REMOVED***
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
***REMOVED***
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) ***REMOVED***
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    ***REMOVED***
  ***REMOVED***;
***REMOVED*** catch (e) /* istanbul ignore next */ ***REMOVED***
  module.exports = ***REMOVED***
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  ***REMOVED***;
***REMOVED***
