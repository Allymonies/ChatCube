'use strict';

const ***REMOVED*** Duplex ***REMOVED*** = require('stream');

/**
 * Emits the `'close'` event on a stream.
 *
 * @param ***REMOVED***Duplex***REMOVED*** stream The stream.
 * @private
 */
function emitClose(stream) ***REMOVED***
  stream.emit('close');
***REMOVED***

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() ***REMOVED***
  if (!this.destroyed && this._writableState.finished) ***REMOVED***
    this.destroy();
  ***REMOVED***
***REMOVED***

/**
 * The listener of the `'error'` event.
 *
 * @param ***REMOVED***Error***REMOVED*** err The error
 * @private
 */
function duplexOnError(err) ***REMOVED***
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) ***REMOVED***
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  ***REMOVED***
***REMOVED***

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param ***REMOVED***WebSocket***REMOVED*** ws The `WebSocket` to wrap
 * @param ***REMOVED***Object***REMOVED*** [options] The options for the `Duplex` constructor
 * @return ***REMOVED***Duplex***REMOVED*** The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) ***REMOVED***
  let resumeOnReceiverDrain = true;
  let terminateOnDestroy = true;

  function receiverOnDrain() ***REMOVED***
    if (resumeOnReceiverDrain) ws._socket.resume();
  ***REMOVED***

  if (ws.readyState === ws.CONNECTING) ***REMOVED***
    ws.once('open', function open() ***REMOVED***
      ws._receiver.removeAllListeners('drain');
      ws._receiver.on('drain', receiverOnDrain);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    ws._receiver.removeAllListeners('drain');
    ws._receiver.on('drain', receiverOnDrain);
  ***REMOVED***

  const duplex = new Duplex(***REMOVED***
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  ***REMOVED***);

  ws.on('message', function message(msg) ***REMOVED***
    if (!duplex.push(msg)) ***REMOVED***
      resumeOnReceiverDrain = false;
      ws._socket.pause();
    ***REMOVED***
  ***REMOVED***);

  ws.once('error', function error(err) ***REMOVED***
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  ***REMOVED***);

  ws.once('close', function close() ***REMOVED***
    if (duplex.destroyed) return;

    duplex.push(null);
  ***REMOVED***);

  duplex._destroy = function (err, callback) ***REMOVED***
    if (ws.readyState === ws.CLOSED) ***REMOVED***
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    ***REMOVED***

    let called = false;

    ws.once('error', function error(err) ***REMOVED***
      called = true;
      callback(err);
    ***REMOVED***);

    ws.once('close', function close() ***REMOVED***
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    ***REMOVED***);

    if (terminateOnDestroy) ws.terminate();
  ***REMOVED***;

  duplex._final = function (callback) ***REMOVED***
    if (ws.readyState === ws.CONNECTING) ***REMOVED***
      ws.once('open', function open() ***REMOVED***
        duplex._final(callback);
      ***REMOVED***);
      return;
    ***REMOVED***

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) ***REMOVED***
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    ***REMOVED*** else ***REMOVED***
      ws._socket.once('finish', function finish() ***REMOVED***
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      ***REMOVED***);
      ws.close();
    ***REMOVED***
  ***REMOVED***;

  duplex._read = function () ***REMOVED***
    if (
      (ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) &&
      !resumeOnReceiverDrain
    ) ***REMOVED***
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    ***REMOVED***
  ***REMOVED***;

  duplex._write = function (chunk, encoding, callback) ***REMOVED***
    if (ws.readyState === ws.CONNECTING) ***REMOVED***
      ws.once('open', function open() ***REMOVED***
        duplex._write(chunk, encoding, callback);
      ***REMOVED***);
      return;
    ***REMOVED***

    ws.send(chunk, callback);
  ***REMOVED***;

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
***REMOVED***

module.exports = createWebSocketStream;
