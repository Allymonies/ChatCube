'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
***REMOVED***);
exports.default = expressWs;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _express = require('express');

var _express2 = _interopRequireDefault(_express);

var _ws = require('ws');

var _ws2 = _interopRequireDefault(_ws);

var _websocketUrl = require('./websocket-url');

var _websocketUrl2 = _interopRequireDefault(_websocketUrl);

var _addWsMethod = require('./add-ws-method');

var _addWsMethod2 = _interopRequireDefault(_addWsMethod);

function _interopRequireDefault(obj) ***REMOVED*** return obj && obj.__esModule ? obj : ***REMOVED*** default: obj ***REMOVED***; ***REMOVED***

function expressWs(app, httpServer) ***REMOVED***
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ***REMOVED******REMOVED***;

  var server = httpServer;

  if (server === null || server === undefined) ***REMOVED***
    /* No HTTP server was explicitly provided, create one for our Express application. */
    server = _http2.default.createServer(app);

    app.listen = function serverListen() ***REMOVED***
      var _server;

      return (_server = server).listen.apply(_server, arguments);
    ***REMOVED***;
  ***REMOVED***

  /* Make our custom `.ws` method available directly on the Express application. You should
   * really be using Routers, though. */
  (0, _addWsMethod2.default)(app);

  /* Monkeypatch our custom `.ws` method into Express' Router prototype. This makes it possible,
   * when using the standard Express Router, to use the `.ws` method without any further calls
   * to `makeRouter`. When using a custom router, the use of `makeRouter` may still be necessary.
   *
   * This approach works, because Express does a strange mixin hack - the Router factory
   * function is simultaneously the prototype that gets assigned to the resulting Router
   * object. */
  if (!options.leaveRouterUntouched) ***REMOVED***
    (0, _addWsMethod2.default)(_express2.default.Router);
  ***REMOVED***

  // allow caller to pass in options to WebSocketServer constructor
  var wsOptions = options.wsOptions || ***REMOVED******REMOVED***;
  wsOptions.server = server;
  var wsServer = new _ws2.default.Server(wsOptions);

  wsServer.on('connection', function (socket, request) ***REMOVED***
    if ('upgradeReq' in socket) ***REMOVED***
      request = socket.upgradeReq;
    ***REMOVED***

    request.ws = socket;
    request.wsHandled = false;

    /* By setting this fake `.url` on the request, we ensure that it will end up in the fake
     * `.get` handler that we defined above - where the wrapper will then unpack the `.ws`
     * property, indicate that the WebSocket has been handled, and call the actual handler. */
    request.url = (0, _websocketUrl2.default)(request.url);

    var dummyResponse = new _http2.default.ServerResponse(request);

    dummyResponse.writeHead = function writeHead(statusCode) ***REMOVED***
      if (statusCode > 200) ***REMOVED***
        /* Something in the middleware chain signalled an error. */
        dummyResponse._header = '';
        socket.close();
      ***REMOVED***
    ***REMOVED***;

    app.handle(request, dummyResponse, function () ***REMOVED***
      if (!request.wsHandled) ***REMOVED***
        /* There was no matching WebSocket-specific route for this request. We'll close
         * the connection, as no endpoint was able to handle the request anyway... */
        socket.close();
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  return ***REMOVED***
    app: app,
    getWss: function getWss() ***REMOVED***
      return wsServer;
***REMOVED***
    applyTo: function applyTo(router) ***REMOVED***
      (0, _addWsMethod2.default)(router);
    ***REMOVED***
  ***REMOVED***;
***REMOVED*** /* This module does a lot of monkeypatching, but unfortunately that appears to be the only way to
   * accomplish this kind of stuff in Express.
   *
   * Here be dragons. */